#!/bin/bash

###############################################################################
###
### NAME
###     kit - A multi-call (like BusyBox) bash script/library/framework
###
### DESCRIPTION
###     Like BusyBox, the kit script can be invoked in several different ways:
###       ln -s kit functionName
###           :
###       functionName argument...
###           Creating a symlink to the script allows the function with the
###           exact same name as the symlink to be invoke as a command.
###       kit --alt functionName argument...
###           Invoke functionName instead of function 'kit'
###       source kit
###           :
###       functionName argument...
###           The entire kit script can be sourced. Watch out for variable
###           and function name conflicts.
###
###############################################################################

###############################################################################
#
#   COMMAND SEARCH PATH
#     Prerequisite for SOURCES so they can be found
#
###############################################################################

# export PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:$HOME/bin"
### set PATH - commands in user's bin canNOT override system
### 20200206  Disabled as it was preventing homeassistant from running script


###############################################################################
#
#   SECURITY
#     Prerequisite that this script have executable permissions
#
###############################################################################

[[ -x "$0" ]]  || {
  xmessage -center -timeout 10 "  ACCESS DENIED -- For security, '$0' must be executable as it contains shell script code " &
  exit 1
}
### ABORT if this file not executable


###############################################################################
#
#   CONSTANTS & PREFERENCES
#     These SHOULD NEVER BE REASSIGNED by scripts sourcing kit.
#     (Cannot use functions to set these as infractructure not yet setup.)
#
###############################################################################

ENVVARS="$(compgen -v | sort)"
### inherited environment variables

SCRIPTARGS="$*"
### preserve original script commandline arguments

# kit Identification
kit_NAME='kit'
kit_SCRIPT='kit-045'
kit_VERSION='0.4.5'
kit_META='kit-045.meta'
kit_AUTHOR='Robert "DocSalvager" Watson'
kit_TOOLTIP='kit functions library'
kit_MANUAL='Kit'
kit_CONF="$HOME/.config/kit/${kit_SCRIPT}.conf"
kit_SCRIPT_AT="$(which $kit_SCRIPT)"

VARPFX="kit_"
VARLIST="${!kit_@}" ### Parameter Expansion syntax requires the prefix to be a literal
for I in $VARLIST
do
  J="${I#"$VARPFX"}"
  ### trim namespace prefix
  #
  declare $J="${!I}"
  ### re/create common variable (declare required due to variable lvalue)
  #
  # printf "%-s ...\n    %-s\n"  "$I" "${!I}"
  # printf "%-s ...\n    %-s\n\n"  "$J" "${!J}"
  ### diagnostic
  #
done
unset I J
### Set global identification variables from local script variables.
### In scripts sourcing this script, a similar block of code will override these.
###   NAME="$kit_NAME"
###   SCRIPT="$kit_SCRIPT"
###       :

source "$kit_CONF"  || {
  xmessage -center -timeout 10 "  ABORTED -- Configuration file '$kit_CONF' not found  " &
  exit 1
}
### load configuration file

# echo "
# PATH:           '$PATH'
# HOME:           '$HOME'
# HOMEDIR:        '$HOMEDIR'
# kit_SCRIPT:     '$kit_SCRIPT'
# kit_SCRIPT_AT:  '$kit_SCRIPT_AT'
# "
# ### diagnostic

# echo "kit_CONF:  $kit_CONF"  >&2
# echo "$(comm -1 -3 <(sort <<< "$ENVVARS") <(compgen -v | sort))"  >&2
# exit
# ### diagnostic


###############################################################################
#
#   GLOBAL VARIABLES
#     Many of these may be reassigned by scripts sourcing kit.
#     (Cannot use functions to set these as infractructure not yet setup.)
#
#     Dependancies must be in directories relative to...
#       HOME        Standard Linux environment variable containing user's directory
#       HOMEDIR     Topmost "root" (nominally, /home/DocSalvager).
#                   This may be set externally (i.e. in $HOME/kit/kit-<ver>.conf).
#                   If not set already, set to parent of directory containing kit.
#       BINDIR      Directory containing this script or symlink that ultimately
#                   points to it, possibly including numerous intermediate links.
#                   Usually $HOMEDIR/bin.
#       LIBDIR      Directory containing this script. Usually $HOMEDIR/lib.
#
#     Set in kit only...
#       ENVVARS                     ### inherited environment variables  (set above)
#       SCRIPTARGS                  ### original script commandline args (set above)
#
#     Usually set in ${kit_SCRIPT}.conf)...
#       MARGINS                     ### default window text margins
#       GEOMETRY_TL                 ### window top-left
#       GEOMETRY_PL                 ### window size in pixels - large
#       GEOMETRY_PS                 ### window size in pixels - small
#       GEOMETRY_CLH                ### window size in charactors - large - height
#       GEOMETRY_CLW                ### window size in charactors - large - width
#       GEOMETRY_CSH                ### window size in charactors - small - height
#       GEOMETRY_CSW                ### window size in charactors - small - width
#       SCREEN_SIZE                 ### screen size in pixels (WxH)
#       TEXTMAXSMALL                ### max charactors allowed in a small window
#       HELPFONT                    ### window font
#       HELPCOLORBG                 ### --text-info text color - background
#       HELPCOLORFG                 ### --text-info text color - foreground
#       IFSDEF                      ### default IFS
#       INSPFRAGLEN                 ### inspFn() output fragment length default
#       YAD                         ### path to YAD binary
#       MANHOST                     ### known host containing manpages
#
#     Initialized in kit-000.___init()...
#       AUTHOR                      ### executing script author's name
#       NAME                        ### executing script name w/o version suffix
#       SCRIPT                      ### executing script name with version suffix
#       VERSION                     ### executing script version# in dot format
#
#       ARCHIVESDIRNAME             ### dir of archived versions of files in a directory
#       HOST                        ### local host name
#       HOSTremote                  ### optional remote host name (usually "")
#       INSPFILE                    ### full path of inspection output file
#       LOGDIR                      ### user directory to place log file for this run
#       LOGFILE                     ### log file in $LOGDIR/ dir
#       METAFILE                    ### kit.meta script full path and filename
#       PACKAGES                    ### all local package files in varioius formats
#       REQDIRS                     ### required directories
#       REQFILES                    ### required output files
#       TMPDIR                      ### full path of directory for this invocation
#       TMPDIRS                     ### full path of directory for all kit temporary files
#
#       DLG                         ### best dialog command available (yad, zenity, dialog...)
#       GTK2DESKLET                 ### gtkdialog addon for transparent windows - 20190605 OBSOLETE
#       TITLE                       ### default output title used in dialog
#       UI                          ### user interface (CLI, GUI or LOG)
#
#       TIMELAST                    ### most recent time
#       TIMESTART                   ### start time
#
#       HELPCOMMON                  ### help text common to all functions
#       INSPECT                     ### inspection mode flag (null, 1, 2)
#       SPINNERPID                  ### spinner pid
#
#       EUSER                       ### Effective user name
#       RUSER                       ### Real user name
#
#       ARGSLINE                    ### collapsed fragment of commandline needed for inspFn()
#       CMD                         ### command and arguments array to use in execution
#       cmd_PATH                    ### command script full path and filename
#       cmd_DIR                     ### command script path to parent directory
#       cmd_FILE                    ### command script filename
#       kit_SCRIPT_AT                    ### kit script full path and filename
#       kit_DIR                     ### kit script path to parent directory
#       kit_FILE                    ### kit script filename
#       kit_CONF                    ### kit configuration file for local host
#
###############################################################################

shopt -s extglob
### shell options

ulimit -s 16384                         ### double stack memory limit
### user memory limit changes

FUNCNEST=128
### limit fn nesting to abort endless loops
### new for bash 4.4.23?

MARGINS=8

HELPCOLORBG="#000000"
# HELPCOLORBG="#B5B6B5"
# HELPCOLORBG="#A5BACE"

HELPCOLORFG="#00FF00"
# HELPCOLORFG="#00A610"
# HELPCOLORFG="#00F500"
# HELPCOLORFG="#07A410"
# HELPCOLORFG="#00FF20"

IFSDEF="$IFS"
### default IFS

INSPFRAGLEN=80
### inspFn() output fragment length default

GEOMETRY_TL="${GEOMETRY_TL:-+0+0}"
GEOMETRY_PL="${GEOMETRY_PL:-700x600}"
GEOMETRY_PS="${GEOMETRY_PS:-660x200}"
GEOMETRY_CLH="${GEOMETRY_CLH:-40}"
GEOMETRY_CLW="${GEOMETRY_CLW:-100}"
GEOMETRY_CSH="${GEOMETRY_CSH:-8}"
GEOMETRY_CSW="${GEOMETRY_CLW:-100}"
TEXTMAXSMALL="${TEXTMAXSMALL:-2000}"
### GUI window property defaults if not already set in kit-___.conf
### TODO:
###   Determine screen size automatically and set reasonable limits

HELPFONT="${HELPFONT:-Monospace 10}"
# HELPFONT="${HELPFONT:+$HELPFONT, }Monospace 10"
# HELPFONT="Mono,Fixed 11"
# HELPFONT="Liberation Mono 10,Fixed 10"
# HELPFONT="Liberation Mono 10,Fixed Normal 10"
# HELPFONT="Liberation Mono,Fixed Normal 12"
# HELPFONT="Liberation Mono,Fixed,Nimbus Mono L Normal 12"
# HELPFONT="Nimbus Mono L 12,Liberation Mono 12"
# HELPFONT="Liberation Mono 12,Nimbus Mono L 12,Fixed 12"

YAD="${YAD:-yad}"
### path to YAD binary (usually set to full path in ${kit_SCRIPT}.conf)

export LC_ALL=C
export LANG=C
export LANGUAGE=C
export LC_COLLATE=C
# export LANG="en_US.UTF-8"
# export LANGUAGE="en_US.UTF-8"
# export LC_ALL="en_US.UTF-8"
# export LC_COLLATE="en_US.UTF-8"
### locale
###   grep and sort need these set to 'C' for things to work predictably
###   gnome-terminal needs 'en_US.UTF-8' to prevent a DBus crash status 8 so prefix...
###       LC_ALL="en_US.UTF-8"  gnome-terminal ...
### 20190413  REVISED

export DISPLAY=:0
### required for GUI processes to access display owned by another (i.e. alpha)

NL=$'\n'                                ### Newline for YAD since \n not supported
T=""                                    ### indentation string (2 spaces per tab)

reDquote='"'
reSquote="'"
reComment='/#/'
reOption='-[-[:alnum:]]*'
reOptionArg='-[-[:alnum:]]*[[:space:]]*[[:alnum:]]*'
reVar='^[[:alpha:]_][[:alnum:]_]*'
reVarEq="$reVar[=]"
reNonComment='^[^#].*'                  ### Not a comment or blank line
reNumber='^[0-9]+$'
### Common Regular Expressions

globVer='-+([0-9])'
### glob pattern for versioning kit-0..., kit-000..., kit-000-00...

RS="\033[0m"    # reset
HC="\033[1m"    # hicolor
BO="\033[21m"   # bold (some systems)
UL="\033[4m"    # underline
RV="\033[7m"    # reverse background and foreground
FBLK="\033[30m" # foreground black
FRED="\033[31m" # foreground red
FGRN="\033[32m" # foreground green
FYEL="\033[33m" # foreground yellow
FBLU="\033[34m" # foreground blue
FMAG="\033[35m" # foreground magenta
FCYN="\033[36m" # foreground cyan
FWHT="\033[37m" # foreground white
BBLK="\033[40m" # background black
BRED="\033[41m" # background red
BGRN="\033[42m" # background green
BYEL="\033[43m" # background yellow
BBLU="\033[44m" # background blue
BMAG="\033[45m" # background magenta
BCYN="\033[46m" # background cyan
BWHT="\033[47m" # background white
### ANSI color codes

TERMTITLE_SET="\033]0;"
TERMTITLE_END="\007"
### ESCape codes to set terminal title


# ###############################################################################
# #
# # LOAD CONFIGURATION FILE IF ANY
# #   Local overrides for any of the above GLOBAL CONSTANTS AND PREFERENCES
# #
# ###############################################################################
#
# source "$kit_CONF" 2>/dev/null
# ### load local settings if any


###############################################################################
#
# TRAPS
#   TODO
#     Why does this have to be AFTER the kit GLOBALS for trapInterrupt() to work?
#
###############################################################################

# functions inherit the traps:  ERR DEBUG RETURN
set -o errtrace
set -o functrace

# Trap errors
#
# trap trapDebug      DEBUG   ### Triggered before each and every command
# trap trapError      ERR     ### Triggered WHENEVER rc IS FALSE (non-0)
# trap trapExit       EXIT    ### Triggered on exit from sourced (or executed) script?
# trap trapHangup     HUP     ### Triggered on Ctrl-C, ...?
trap trapInterrupt  INT     ### Triggered on Ctrl-C
# trap trapQuit       QUIT    ### Triggered on Ctrl-C, ...?
# trap trapTerminate  TERM    ### Triggered on Ctrl-C, ...?
# trap trapMemory     BUS SEGV  ### Triggered on memory error (UNTESTED!!! BUGGY???)


###############################################################################
#
#  FUNCTIONS
#
###############################################################################

function ___ () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  printf "%s\n" ""
}

function ___exit () {
  local _prc=$?
  # local _prc="$?"
  ### save return code of last command
  #
  fnInit "${FUNCNAME}.20190826" "$@"  && return 0
  ### standard function initialization
  #
  local _files=""
  local _msg=""
  local _msgdone=""
  local _tmpdir="$TMPDIR"
  local _xrc=
  #
  _msg="Remove temporary directory $_tmpdir"
  _msgdone=""
  ### initialize
  #
  # [[ "$1" ]]  && _xrc=$1
  ### an explicit return code overrides _prc
  ### CONFLICTS WITH "$@" LOGIC
  #
  # _ARGS="$*"; inspVar --func INSPECT _tmpdir
  #
  [[ "$INSPECT" ]]  && { inspectShow "$@"; }
  ### --inspect
  #
  _files="$(fileList "$_tmpdir")"
  # _files="$(fileList --all "$_tmpdir/*")"
  #
  GTK_DEBUG=""
  ### disable GTK interactive debugger
  #
  # _ARGS="$*"; inspVar --func _tmpdir
  #
  if [[ "$_files" ]]                              ###<<< 20190526  Disabled to diag kitSync hang
  then
    if [[ "$INSPECT" > "2" ]]
    then
      gtkQuestion "$_msg"  && {
        _msgdone+="$(rm --recursive --verbose "$_tmpdir" 2>&1)"
        gtkInfo "$_msgdone"
        # log --status "$_msgdone"
        ### remove files and dir
      }
      # dialogConfirm --text "$_msg" --info "$_files"  && {
      #   _msgdone+="$(rm --recursive --verbose "$_tmpdir" 2>&1)"
      #   gtkInfo "$_msgdone"
      #   # log --status "$_msgdone"
      #   ### remove files and dir
      # }
      ### only remove files and dir if confirmed
    else
      _msgdone+="$(rm --recursive --verbose "$_tmpdir" 2>&1)"
      # rm --recursive --verbose "$_tmpdir" 2>&1 >>"$LOGFILE"
      ### silently remove files
    fi
  else
    _msgdone+="$(rmdir --verbose "$_tmpdir" 2>&1)"
    # rmdir --verbose "$_tmpdir" 2>&1 >>"$LOGFILE"
    ### always remove empty directory
  fi
  ### remove temporary directory and files if not inspecting
  #
  log --arguments "$_msgdone"
  ### log the cleanup
  #
  log --stop "$0 $SCRIPTARGS"
  ### end logging
  #
  exit $_prc
  ### exit with return code of previous function
  #
  # [[ "$1" ]]  && exit $1  || exit $_prc
  ### exit with explicit return code if one provided, or...
  ### exit with return code of last command before call to this function
  ### CONFLICTS WITH "$@" LOGIC
}

function ___init () {
  # echo "${FUNCNAME[2]} --> ${FUNCNAME[1]} -->     ${FUNCNAME[0]}: ${CMD[@]}..." >&2
  #
  fnInit "${FUNCNAME}.20190911" "$@"  && return 0
  # fnInit ${FUNCNAME} "$@"  && return 0
  ### function initialization for --help, --version, etc.
  #
  local __=""
  local _fn=""
  local _a1=1
  local _errmsg=""
  #
  ###
  ###   REASSIGN GLOBAL VARIABLES FOR kit
  ###     Can use functions to set these.
  ###
  #
  TIMESTART=$(timeMs); TIMELAST=$TIMESTART
  ### start the clock on this process
  #
  HOMEDIR="${HOMEDIR:-$HOME}"; [[ "$HOMEDIR" ]]  || { echo -e "${NL}\$HOMEDIR unknown:  '$HOMEDIR'${NL}"; exit 1; }
  ### mandatory HOMEDIR variable on which many other things are based
  ### HOMEDIR should already be set in kit_CONF
  #
  NAME="${NAME:-$kit_NAME}"
  SCRIPT="${SCRIPT:-$kit_SCRIPT}"
  VERSION="${VERSION:-$kit_VERSION}"
  AUTHOR="${AUTHOR:-$kit_AUTHOR}"
  ### default to kit_ unless set by script sourcing this one
  #
  EUSER="$(id -un)"
  RUSER="$(id -run)"
  ### Effective and Real user names
  #
  HOST="$(hostname)"
  MANHOST="${MANHOST:-$HOST}"
  ARCHIVESDIRNAME=".archives"
  #
  CACHEDIR="${CACHEDIR:-$HOMEDIR/cache}"
  TMPDIRS="${TMPDIRS:-$HOMEDIR/tmp}"
  ### HOMEDIR directories
  #
  LOGDIR="${LOGDIR:-$HOME/log}"  || { LOGDIR="$HOMEDIR/log"; }
  ### HOME directories
  #
  PACKAGES="/boot/arc/pkg"
  REQDIRS='bin cache etc icons img lib log man'
  #
  # CACHEFILE set in function or external-script
  INSPFILE="${INSPFILE:-$HOMEDIR/cache/$SCRIPT.inspect}"
  LOGFILE="${LOGFILE:-$LOGDIR/$SCRIPT.log}"
  #
  # METAFILE set below
  REQFILES='METAFILE LOGFILE'
  #
  log --start "$0 $SCRIPTARGS"
  ### begin logging
  #
  isDirWrite "/tmp/kit"  || {
    _errmsg="$(mkdir --mode=1777 -p "/tmp/kit")"              || { abortShow operationfailed "$_errmsg"; }
  }
  ### insure kit parent tmp dir exists, is writable and has sticky bit (only owner alterable)
  #
  isDirWrite "$TMPDIRS"  || {
    _errmsg="$(cd "$HOMEDIR"; ln -sf "/tmp/kit" "$TMPDIRS")"  || { abortShow operationfailed "$_errmsg"; }
  }
  #
  TMPDIR="$(dirOpen "$TMPDIRS/$$")"
  ### be sure /tmp/kit exists and setup tmp directory
  #
  # echo "TMPDIR:  '$TMPDIR'" >&2
  ### diagnostics
  #
  [[ "$INSPECT" > "1" ]]  && { echo -e "\nTMPDIR= $TMPDIR\n" >&2; }
  ### diagnostic
  #
  # GTK2DESKLET="${GTK2DESKLET:-$HOMEDIR/lib/gtk-2.0/modules/libgtk2desklet.so}"
  ### allows gtkdialog dialogs to have transparent windows such as for spinners
  ###   20190605 - OBSOLETE
  #
  TITLE="${TITLE:-$SCRIPT}"
  ### default output title
  #
  SPINNERPID="$(gtkSpinner --tip "Initializing kit...")"
  ### start busy spinner and save the pid
  ###  NOTE
  ###   Always use SPINNERPID instead of a local variable
  ###   to insure only 1 spinner running at a time
  #
  kit_SCRIPT_AT="$(pathStr --path ${BASH_SOURCE[0]})"
  kit_DIR="$( pathStr --dir  ${BASH_SOURCE[0]})"
  kit_FILE="$(pathStr --file ${BASH_SOURCE[0]})"
  ### execution path of this script
  ### (these will show whether script is running from a bin/ or a lib/ directory)
  #
  export PATH="$PATH:$kit_DIR"
  ### add kit_DIR to PATH so dependant scripts can find us when sourcing
  #
  METAFILE="${METAFILE:-$kit_DIR/$kit_META}"
  ### default METAFILE must be in same directory as this script
  #
  # for F in "$kit_SCRIPT_AT" "$kit_DIR/$kit_META"
  # do
  #   [[ -x "$F" ]]  || {
  #     dialog --text="  Access Denied$NL    For security, '$F' must be executable as it contains shell script code.  " &
  #     exit 1
  #   }
  # done
  ### 20190707  OBSOLETE - set near start of each script
  #
  cmd_PATH="$(pathStr --path "$0")"
  cmd_DIR="$( pathStr --dir  "$0")"
  cmd_FILE="$(pathStr --file "$0")"
  ### if executing script sorced this script,
  ### these may be different from their kit_ counterparts
  #
  for D in $REQDIRS
  do
    isDirWrite "$HOMEDIR/$D"              && { continue; }
    #
    log --status "$NL  Created directory '$D':  $(dirOpen -- "$HOMEDIR/$D")"
  done
  ### insure default directories are in place
  #
  for F in $REQFILES
  do
    isFileExists "${!F}"                  && { continue; }
    #
    FILE="$(fileOpen "${!F}")"
    ### create file
    #
    log --status "$NL  Created file '$F':  '$FILE'"
    #
    FILE=""
  done
  ### insure required files are in place (see below for INSPFILE)
  #
  (( ${BASH_VERSINFO[0]} >= 4 )) && {
    declare -A gtkdialog_wintype=([NORMAL]="0" [DIALOG]="1" [MENU]="2" [TOOLBAR]="3" [SPLASHSCREEN]="4" [UTILITY]="5" [DOCK]="6" [DESKTOP]="7")  2>/dev/null
    ### GtkDialog type-hint attribute
    ###   Associative arrays not supported in Bash till versions 4.0+
  }
  ### bash version 4+ enhancements
  #
  HELPCOMMON="$(note "kit_common")"
  ### common help
  #
  INSPECT="$(optionArg --inspect  "$@")"  && { [[ "$INSPECT" ]]  || { INSPECT=1; }; }
  # isOption --inspect  "$@"  && INSPECT="1"
  #
  [[ "$INSPECT" == "3" ]]  && { export GTK_DEBUG=interactive; }
  ### set GTK_DEBUG to invoke the GTK Inspector
  #
  [[ "$INSPECT"        ]]  && { >"$INSPFILE"; }
  ### start with empty file
  ### cache directory will always contain last INSPFILE
  #
  #
  ###
  ### Establish which command(function) to actually execute
  ###
  #
  CMD="${cmd_FILE##*/}"; CMD="${CMD/${globVer}/}"
  # CMD="${cmd_FILE/${globVer}/}"
  ### name script was invoked with (i.e. kit, meta, archive, kit-043, ...)
  ###   less the version suffix, if any
  #
  YAD="${YAD:-yad}"
  ### default yad command in PATH
  #
  # GEOMETRY_TL=\"$GEOMETRY_TL\"
  # GEOMETRY_PL=\"$GEOMETRY_PL\"
  # GEOMETRY_PS=\"$GEOMETRY_PS\"
  # GEOMETRY_CLH=\"$GEOMETRY_CLH\"
  # GEOMETRY_CLW=\"$GEOMETRY_CLW\"
  # GEOMETRY_CSH=\"$GEOMETRY_CSH\"
  # GEOMETRY_CSW=\"$GEOMETRY_CSW\"
  # TEXTMAXSMALL=\"$TEXTMAXSMALL\"
  # ### GUI window properties
  #
  # HELPFONT=\"$HELPFONT\"
  #
  # YAD=\"$YAD\"
  # ### yad binary or symlink to a binary on this host to bypass antiX wrapper script
  # "  >> "$kit_CONF"
  #     }
  #   }
  ### 20190110  EXPERIMENTAL - if configuration file not found, create it from defaults
  #
  #
  CMD=( "$CMD" "$@" )
  # CMD=( "$CMD" "$@" ); CMD="${CMD[0]:-$CMD}"; CMD[0]="$CMD"
  ### CMD is either CMD[0] or CMD invoked with
  ### CMD[] contains any subsequent arguments
  #
  ___initUIDLG "$@"
  #___initUIDLG "${CMD[@]:1}"
  ### set UI (user interface) and DLG (dialog tool)
  #
  gtkSpinner --stop "$SPINNERPID"
  ### turn off spinner
  #
  # echo "
  #   SPINNERPID: '$SPINNERPID'
  # "  >&2
  ### diagnostic
  #
  return 0
}

function ___initUIDLG () {
  ### delaying fnInit till end of function in order to setup user interface
  #
  local _ui=""
  local _dlg=""
  local _nodlg=""
  ### declarations
  #
  isOption --NODLG "$@"  && _nodlg="NODLG"
  ### force no dialog use
  #
  #
  ### SET UI
  #
  tty -s            && { _ui="CLI"; }
  ### detect CLI (interactive commandline) interface
  ###   The 'tty -s' command returns true(0) if in an interactive session (a shell
  ###   command line) since a tty is in use. Otherwise false(1).
  ###   The widely used test...
  ###     if [[ -z "$PS1" ]]
  ###   is unreliable since things like SSH sftp connections, use their own
  ###   internal commandline instead of using a tty so 'tty -s' returns false(1).
  #
  [[ "$DISPLAY" ]]  && { _ui="GUI"; }
  ### detect GUI interface
  #
  isOption --LOG  "$@"  && _ui="LOG"
  isOption --CLI  "$@"  && _ui="CLI"
  isOption --GUI  "$@"  && _ui="GUI"
  ### force user interface change if option supplied
  ###   if multiple ui options supplied, set to best
  #
  _ui="${_ui:-LOG}"
  ### default to LOG if still not set
  #
  #
  ### SET DLG
  #
  [[ "$_ui" == "GUI" ]]  && {
    if [[ "$_nodlg" ]]
    then
      _ui="CLI"
      _dlg=""
    else
      which zenity >/dev/null 2>&1  && { _dlg='zenity'; }
      ### use zenity if available
      #
      which yad    >/dev/null 2>&1  && { _dlg='yad'   ; }
      ### prefer yad if available
      #
      [[ "$_dlg" ]]  || { _ui="CLI"; }
      ### force to CLI if no dialoger software
    fi
    ### look for a dialoger unless --NODLG option
  }
  #
  [[ "$_ui" == "CLI" ]]  && {
    if [[ "$_nodlg" ]]
    then
      _dlg=""
    else
      which dialog >/dev/null 2>&1  && { _dlg='dialog'; }
      ### CLI dialoger is dialog(aka cdialog) if found
    fi
    ### look for a commandline dialoger unless --NODLG option
  }
  #
  # _ARGS="$*"; inspVar --func
  #
  UI="$_ui"
  DLG="$_dlg"
  # isOption --ui  "$@"  && { echo "$_ui" ; return 0; }
  # isOption --dlg "$@"  && { echo "$_dlg"; return 0; }
  # echo "$_ui"
  # echo "$_dlg"
  #
  fnInit "${FUNCNAME}.20190206" "$@"  && return 0
  ### delayed function init till now to get user interface
  #
  return 0
}

function abortDLG () {
  local _msg="Unknown GUI dialog tool"
  #
  [[ "$1" =~ --help ]]  && { noteShow "$FUNCNAME" --title="$TITLE:  $FUNCNAME" "${@:2}"; return 0; }
  # [[ "$1" =~ --help ]]  && { echo "$_msg"; return 1; }
  #
  abortExit operationfailed "$_msg (\$DLG):  '$DLG'"
  ___exit "$@"
}

function abortExit () {
  local _msg="$1"
  #
  [[ "$1" =~ --help ]]  && { noteShow "$FUNCNAME" --title="$TITLE:  $FUNCNAME" "${@:2}"; return 0; }
  #
  printf "\n%s\n%s\n" "$_msg" "  ABORTING at line ${BASH_LINENO[1]}...${NL}    ${*:2}${NL}"
  ___exit "$@"
}

function abortShow () {
  isDirExists "$HOMEDIR/log"  || { abortExit ${FUNCNAME} "$@"; }
  ### abortShow dependencies not available so bail out
  #
  fnInit "$FUNCNAME.20190706" "$@"  && return 0
  #
  errorShow "$1" "ABORTING at line ${BASH_LINENO[1]}...${NL}${NL}${@:2}"
  #
  false; ___exit "$@"
  ### cleanup and exit with non-zero return code to indicate failure
}

function abortUI () {
  local _msg="Unknown User Interface"
  #
  [[ "$1" =~ --help ]]  && { noteShow "$FUNCNAME" --title="$TITLE:  $FUNCNAME" "${@:2}"; return 0; }
  #
  abortExit operationfailed "$_msg (\$UI):  '$UI'"
  # abortExit operationfailed "Unknown User Interface (\$UI):  '$UI'"
  ___exit "$@"
}

function admList () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _db=""
  local _msg=""
  local _admdbs='ahosts ahostsv4 ahostsv6 aliases ethers group gshadow hosts netgroup networks passwd protocols rpc services shadow'
  #
  for _db in $_admdbs
  do
    _msg+="$(printf "%s..." "$_db")$NL"
    _msg+="$(printAt 4 "$(getent $_db 2>&1)")$NL$NL"
  done
  #
  dialog --title "$TITLE: Administrative Databases" -- "$_msg"
  #
  return $?
}

function aliasOf () {
  fnInit "$FUNCNAME.20180208" "$@"  && return 0
  #
  local _fn=""
  local _alias="${FUNCNAME[1]}"
  #
  [[ "$1" ]]  || { "$FUNCNAME" --help; return 0; }
  ### if no arguments, show help
  #
  _fn="$1"
  #
  if isFnLoaded "$_fn"
  then
    CMD="$_fn"
    # CMD[0]="$_fn"; CMD="${CMD[0]}"
    ### change to new CMD function
    #
    # _ARGS="$*"; inspVar --func CMD[@]
    #
    "$_fn" "${@:2}" --before "[ $_alias is an alias of $_fn ]$NL"
    ### call the function
    ### --before will be prepended to help text
    ### NOTE
    ###   'printf' or 'yad --info-text' or some other subsequent processing is
    ###   dropping trailing newlines($NL) so must append a space to get blank lines
  else
    abortShow argumentnotfound "$FUNCNAME:  First argument must be function aliased"
  fi
  #
  return $?
}

function cmdAlt () {
  fnInit "$FUNCNAME.20190501" "$@"  && return 0
  # fnInit ${FUNCNAME} "$@" --revised "20190117"  && return 0
  #
  ### NOTE
  ###   On entry, the CMD[] array has been preset in ___init() to...
  ###     CMD[0]    script name w/o version
  ###     CMD[1...] commandline arguments
  #
  local __=""
  local _a1=
  local _fn=""
  #
  if   [[ "${CMD[1]}" =~ ^--alt= ]]
  then
    _fn="${CMD[1]#--alt=}"
    _a1=2
    ### script --alt=function functionarg1 ...
  elif [[ "${CMD[1]}" =~ ^--alt  ]]
  then
    _fn="${CMD[2]}"
    _a1=3
    ### script --alt function functionarg1 ...
  elif [[ ! "${CMD[1]}" =~ ^--   ]]
  then
    _fn="${CMD[1]}"
    _a1=2
    ### script function functionarg1 ...
    #
    # echo -e "\nargAlt: non-option" >&2
  else
    _fn="${CMD[0]}"
    _a1=1
    ### script --option...
    #
    # echo -e "\nargAlt: option" >&2
  fi
  ### check for --alt option and determine command to execute
  #
  CMD=( "$_fn" "${CMD[@]:$_a1}" )
  # for __ in "$_fn" "${@:$_a1}"; do echo "$__" >&2; done
  # for __ in "$_fn" "${@:$_a1}"; do echo "$__"; done
  #
  # _ARGS="$*"; inspVar --func CMD[@]
  # printf "%q " "$_fn" "${@:$_a1}" >&2; echo -e "\n" >&2
  ### diagnostic
  #
  # printf "%q " "$_fn" "${@:$_a1}"
  # printf "%s\n" "$_fn" "${@:$_a1}"
  ### return new function name to execute followed by its arguments
  ### NOTE - often destined for an array so...
  ###   - array[0] will be the function name
  ###   - array[1]... will be the function's arguments
  #
  return 0
}

# function argAlt_1 () {
#   fnInit "$FUNCNAME.20190501" "$@"  && return 0
#   # fnInit ${FUNCNAME} "$@" --revised "20190117"  && return 0
#   #
#   ### NOTE
#   ###   On entry, the CMD[] array has been preset in ___init() to...
#   ###     CMD[0]    script name w/o version
#   ###     CMD[1...] commandline arguments
#   #
#   local __=""
#   local _a1=
#   local _fn=""
#   #
#   _ARGS="$*"; inspVar --func CMD[@]
#   #
#   if   [[ ! "$@"  ]]
#   then
#     printf "%s" "${CMD[0]}";            return 1
#     ### script
#     #
#     # echo -e "\nargAlt: null" >&2
#     ### diagnostic
#   elif [[ "$1" =~ ^--alt= ]]
#   then
#     _fn="${1#--alt=}"
#     _a1=2
#     ### script --alt=function functionarg1 ...
#   elif [[ "$1" =~ ^--alt  ]]
#   then
#     _fn="$2"
#     _a1=3
#     ### script --alt function functionarg1 ...
#   elif [[ ! "$1" =~ ^-- ]]
#   then
#     _fn="$1"
#     _a1=2
#     ### script function functionarg1 ...
#     #
#     # echo -e "\nargAlt: non-option" >&2
#   else
#     _fn="${CMD[0]}"
#     _a1=1
#     ### script --option...
#     #
#     # echo -e "\nargAlt: option" >&2
#   fi
#   ### check for --alt option and determine command to execute
#   #
#   # for __ in "$_fn" "${@:$_a1}"; do echo "$__" >&2; done
#   # for __ in "$_fn" "${@:$_a1}"; do echo "$__"; done
#   #
#   printf "%q " "$_fn" "${@:$_a1}" >&2; echo -e "\n" >&2
#   ### diagnostic
#   #
#   printf "%q " "$_fn" "${@:$_a1}"
#   # printf "%s\n" "$_fn" "${@:$_a1}"
#   ### return new function name to execute followed by its arguments
#   ### NOTE - often destined for an array so...
#   ###   - array[0] will be the function name
#   ###   - array[1]... will be the function's arguments
#   #
#   return 0
# }

# function argAlt_0 () {
#   fnInit "$FUNCNAME.20190206" "$@"  && return 0
#   # fnInit ${FUNCNAME} "$@" --revised "20190117"  && return 0
#   #
#   ### NOTE
#   ###   On entry, the CMD[] array has been preset in ___init() to...
#   ###     CMD[0]    script name w/o version
#   ###     CMD[1...] commandline arguments
#   #
#   local _cmd="$1"
#   local _fn=""
#   local _a1=
#   #
#   _ARGS="$*"; inspVar --func CMD[@]
#   #
#   [[ "$_cmd"              ]]  || { abortShow argumentnotfound "Missing CMD option"; }
#   ### no arguments
#   #
#   if   [[ ! "$2"          ]]
#   then
#     echo -e "\nnull" >&2
#     ### diagnostic
#     #
#     printf "%s" "$_cmd";                           return 1
#     ### script
#   elif [[ "$2" =~ ^--alt= ]]
#   then
#     _fn="${2#--alt=}"
#     _a1=3
#     ### script --alt=function functionarg1 ...
#   elif [[ "$2" =~ ^--alt  ]]
#   then
#     _fn="$3"
#     _a1=4
#     ### script --alt function functionarg1 ...
#   elif [[ ! "$2" =~ ^-- ]]
#   then
#     _fn="$2"
#     _a1=3
#     ### script function functionarg1 ...
#     #
#     # echo -e "\nnon-option" >&2
#   else
#     _fn="$_cmd"
#     _a1=2
#     ### script --option...
#     #
#     # echo -e "\nkit" >&2
#   fi
#   ### check for --alt option and determine command to execute
#   #
#   printf "%s\n" "$_fn" "${@:$_a1}"
#   ### return new function name to execute followed by its arguments
#   ### NOTE - often destined for an array so...
#   ###   - array[0] will be the function name
#   ###   - array[1]... will be the function's arguments
#   #
#   return 0
# }

function argNoOpt     () { aliasOf argNonOption "$@"; }
### DEPRECATED

function argNoOption  () { aliasOf argNonOption "$@"; }
### DEPRECATED

function argNotOption () { aliasOf argNonOption "$@"; }
### DEPRECATED

function argNonOption () {
  fnInit "$FUNCNAME.20180208" "$@" && return 0
  #
  local _i=
  local _arg=""
  local _found=""
  local _ordinal=
  local _optionarg=""
  local _re_1_99="^[1-9][0-9]?$"
  local _re_option="^-{1,2}[^-].?*$"
  # local _re_option="^[-][-].?*$"
  #
  # inspVarShow _i _argsnum _arg _found _ordinal
  #
  [[ "$1" =~ $_re_1_99 ]]  || { abortShow argumentnotfound "First argument must be the ordinal number of the non-option argument to find"; }
  ### first argument MUST be the ordinal number of the non-option to return
  #
  _ordinal=$1; shift
  # ordinal argument number to return (1-99)
  #
  _i=0
  for _arg in "$@"
  do
    [[ "$_arg" == "--"        ]]  && { _optionarg=""; _i=0   ; continue; }
    ### type:  next args are not option args so they are the positionals we want
    #
    [[ "$_arg" =~ $_re_option ]]  && { _optionarg="OPTIONARG"; continue; }
    ### type:  next args are option arguments so ignore up to next --option
    #
    [[ "$_optionarg"          ]]  && {                         continue; }
    ### arg:   argument is an option argument so ignore it
    #
    ((++_i))
    (( _i == _ordinal ))  && { _found="$_arg"; break; }
    ### arg:   argument is a nonoption(positional) argument
    ###        if it is the ordinal we want, we are done. Otherwise, get next one
  done
  ### let "$@" split commandline, respecting quoted strings
  #
  [[ "$_found" ]]  && { printf "%s" "$_found"; return 0; }
  #
  return 1
}

function argOption    () { aliasOf optionArg    "$@"; }

function argTmp () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _tmpdir=
  mktemp --tmpdir=. zzzz.XXXXX
}

function argsCount () { aliasOf argsNumber "$@"; }

function argsIndexes () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  declare -a _arr
  #
  _arr=( "$@" )
  #
  [[ "$_arr" ]]  && printf "%s " "${!_arr[@]}"
  #
  return 0
}

function argsLast () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  echo "${@:${#@}}"
}

function argsNumber () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  printf "%d" "$#"
  return 0
}

function argsParse () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local o=
  local p=
  local LEN=
  local TYPE=
  #
  log --status
  #
  if [[ "$1" == "" ]]
  then
    log --status "  No options to process"
    return 1
  else
    #
    while [[ "$1" ]]
    do
      if [[ "${1:0:1}" == "-" ]]
      then
        # Long Option (--option | -option)
        #   single-hyphen options interpreted same as double-hyphen
        #   so '-abc' is a single option. Split into '-a' '-b' '-c' deprecated.
        #
        # TYPE="long"
        #
        # separate accompanying argument (=value), if any, from option
        if [[ $1 == *=* ]]
        then
          # --option=argument
          #
          # echo "$TYPE option: ${1%%=*}"
          # echo "$TYPE optarg: \"${1#*=}\""
          #
          printf "%s " "${1%%=*}"
          printf "%s " "\"${1#*=}\""
          #
        elif [[ "${2:0:1}" != "-" ]]
        then
          # --option argument
          #
          # echo "$TYPE option: $1"
          # echo "$TYPE optarg: \"$2\""
          #
          printf "%s " "$1"
          printf "%s " "\"$2\""
          shift
          #
        else
          # --option
          #
          # echo "$TYPE option: $1"
          #
          printf "%s " "$1"
          #
        fi
        #
        shift
        #
      else
        # First Positional Parameter
        #   All positional parameters must be at end of commandline.
        #   Encountering first positional parameter terminates option processing.
        #   Positional parameters will be processed below, outside this loop.
        #
        # TYPE="pos "
        #
        break
      fi
    done
    #
    # Return this and all remaining parameters as fast as possible.
    # Echo each param surrounded by escaped quotes in order to preserve spaces.
    p=0
    for o
    do
      #
      # echo "$TYPE      $p: \"$o\""
      #
      printf "%s " "\"$o\""
      ((++p))
    done
    #
    # echo
    # logStatus "  Returned $p commandline positional parameters"
    #
    return 0
  fi
}

function argsStrings () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _i=""
  local _args=""
  local _reSp="\s"
  #
  for _i in "$@"
  do
    [[ "$_i" =~ $_reSp ]]  && { _args+="\"$_i\" "; continue; }
    ### restore quotes for quoted arguments with embedded spaces (multiple words)
    #
    _args+="$_i "
  done
  #
  # _args="$*"
  #
  _args="${_args% }"
  ### truncate trailing space
  #
  [[ "$_args" ]]  && { printf "%s\n" "$_args"; return 0; }
  #
  return 1
}

function argsValid () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _cmd="$1"; shift
  local _valid=0
  #
  for i in "${@}"
  do
    # output only if arg is valid (no error)
    ($_cmd "$i" >/dev/null 2>&1)  && { ((++_valid)); printf "%s " "$i"; }
  done
  #
  [[ $_valid > 0 ]]  && return 0
  #
  # no valid arguments
  return 1
}

###
### 20190114 - 2 approaches to returning the index of an item in an array passed to a function
###   Cannot find a way to address an array of unknown name passed to a function
###   BOTH FAILED because...
###     arrays apparently cannot be passed to functions
###     passing the name of the array and using indirection also fails
# function arrayIndex () {
#   fnInit ${FUNCNAME} "$@"  && return 0
#   #
#   local -a _arr
#   local _val="$2"
#   local _key=""
#   local _ndx=
#   #
#   _arr="${!1}"
#   _ndx=0
#   for _key in ${_arr[@]}
#   do
#     [[ "$_key" == "$_val" ]]  && printf "%d: %s\n" $_ndx "$_val"; break
#     echo "Is not: $_val"
#     ((++$_ndx))
#   done
#   #
#   _ARGS="$*"; inspVar --func
#   #
# }
#
# function arrayIndex_0 () {
#   fnInit "${FUNCNAME}" "$@" --revised "20190112"  && return 0
#   #
#   local _find="$1"
#   local -n _an="$2"
#   local _val=""
#   local _ndx=
#   local _i=
#   # local -a _arr
#   #
#   _arr=( "${_an[@]}" )
#   #
#   echo "#Indexes: ${#_an[@]}"
#   echo "_an:  ${_an[@]}"
#   #
#   _ndx=0
#   #
#   for _val in ${_arr[@]}
#   do
#     echo "_find:  $_find"
#     echo "_ndx:  $_ndx"
#     echo "_val:  $_val"
#     [[ "$_val" == "$_find" ]]  && { printf "Found %s at index: %d\n" "$_val" $_ndx; return 0; }
#     ((++_ndx))
#   done
#   # for ((_ndx=0; _ndx < ${#_arr[@]}; ++_ndx))
#   # # for _ndx in "${!_arr[@]}"
#   # do
#   #   echo "_find:  $_find"
#   #   echo "_ndx:  $_ndx"
#   #   echo "_arr[]:  ${_arr[$_ndx]}"
#   #   [[ "${_arr[$_ndx]}" == "$_find" ]]  && { printf "\n%d\n" $_ndx; return 0; }
#   #   # ((++_ndx))
#   # done
#   #
#   _ARGS="$*"; inspVar --func
#   #
#   echo "not found"
#   #
#   return 1
# }

function  batchExec () {
  fnInit "$FUNCNAME.20180208" "$@"  && return 0
  #
  local _result=""
  local _logfile=""
  #
  _result="$("$@")"
  #
  ( _logfile=/dev/stderr; log --status "Results of executing... $@ ::: $_result" )
  ### in subshell to preserve global $LOGFILE
  #
  [[ $_result ]]  && return 0
  #
  return 1
}

function calledByMain ()  {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ ${FUNCNAME[2]} == main ]] && return 0
  return 1
}

function calledBySelf ()  {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ ${FUNCNAME[1]} == ${FUNCNAME[2]} ]] && return 0
  return 1
}

function cliInput () { aliasOf inputCli "$@"; }

function cmdType () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _arg="$1"
  local _typ=""
  #
  [[ "$_arg"       ]]           || return 1
  ### requires an argument
  #
  [[ "$_arg" =~ ^- ]]           && return 1
  ### options cannot be commands
  #
  _typ="$(type -t "$_arg")"     || return 1
  #
  echo "$_typ"
  return 0
}

function  colorPref () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _key="$1"
  local _key="${_key%_color}"               # remove _color suffix if any
  local _var="${_key//-/_}"                 # hyphens illegal in variable names
  local _metafile="$(optionArg --metafile "$@")"
  local _colorpref="${_var}_color"          # color preference definition (variable name)
  local _found=""
  local _topic=""
  local _item=""
  local _text=""
  local _val=""
  #
  _metafile="${_metafile:-$METAFILE}"; [[ "$_metafile" ]]  || {
    abortShow filenotfound "No --metafile=FILE option and \$METAFILE not yet set"
  }
  ### default meta file if not supplied
  #
  _topic="Hex:"; isOption --notes "$@"  && { _topic="Notes:"; }
  ### set _topic to the meta data to retrieve (default to "Hex:")
  #
  _found="$(varFind "$_colorpref" --metafile "$_metafile")"  || {
    errorShow operationfailed "Color preference not found:  $_colorpref";   return 1; }
  #
  # _text+="${_var}_color"; }
  #
  eval "${_colorpref}=\"$_found\""
  # { _item+="$(varFind "${_var}_color" --metafile "$_metafile")"; }  &&
  #     { _found="${_item%%=*}"; eval "$_item"; _text+="${!_found}"; }
  ### find an item and interpret Command Subsitution ( $(...) ) via eval
  ###   WARNING -- SECURITY ISSUE
  ###     Code may be embedded in $kit_META items.
  #
  _val="$(topic "$_topic" "$_found")"  || { errorShow operationfailed "Unknown color:  $_key"; return 1; }
  ### get either Hex: or Notes: value
  #
  # _val="$(varTrim "$_val")"
  ### remove any leading or trailing spaces
  #
  # _ARGS="$*"; inspVar --func
  #
  [[ "$_val"                      ]]  && { printf "%s" "$_val"                              ; return 0; }
  ### print if anything to print
  #
  return 1
}

function commands () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _dir=""
  local _file=""
  local _dirsinpath=""
  local _msg=""
  #
  isOption --paths "$@"  && {
    _msg="$(
      IFS=: read -ra _dirsinpath <<< "$PATH"
      for _dir in "${_dirsinpath[@]}"
      do
        for _file in "$_dir"/*
        do
          [[ -x "$_file" && -f "$_file" ]]  && { printf '%s\n' "${_file}"; }
          # [[ -x "$_file" && -f "$_file" ]]  && { printf '%s\n' "${_file##*/}"; }
        done
      done
    )"
  }
  #
  [[ "$_msg" ]]  || { _msg="$(names "$@" --type command)"; }
  ### "$@" must be first options so that the '--help' inserted by meta is first
  #
  echo "$_msg"
  #
  return 0
}


function commandType () { aliasOf cmdType "$@"; }

function confirm () { aliasOf dialogConfirm "$@"; }

function confirmExec () {
  fnInit "$FUNCNAME.20180208" "$@"  && return 0
  #
  local _ans=
  local _logfile=""
  local _result=
  #
  if $(dialogConfirm "Execute $@")
  then
    # if $( "$@" | tee >( _result=$(guiProgress $MAXOPT $MAX "Executing:  $CMD ...") ) )  2>>$kit_LOG
    # if $( "$@" | tee >( _result=$(guiProgress $MAXOPT $MAX "Executing:  $CMD ...") ) )
    #
    # NOTE: No _result passed back if guiProgress executed in background
    # if _result="$("$@" | guiProgress $MAXOPT $MAX "Executing:  $CMD ...")"
    #
    if _result="$("$@")"                                    ###<<<<<< 20141103 @Unsolved: Why is help MODAL???
    then
      ( _logfile=/dev/stderr; log --status "Results of executing... $@ ::: $_result" )
      return 0
    else
      ( _logfile=/dev/stderr; log --status "Results of executing... $@ ::: $_result" )
      return 1
    fi
  else
    if [[ $? == 1 ]]
    then
      return 1
    else
      return 0
    fi
  fi
}

function diagnostics () { aliasOf inspect "$@"; }

function dialog () {
  fnInit "$FUNCNAME.20200426" "$@" && return 0
  #
  # echo "'$HOST: $HOSTremote'" >&2
  #
  # [[ "$HOSTremote" == "FAILED" ]]  || return 1
  # fnInit ${FUNCNAME} "$@"  && return 0  || { [[ "$HOSTremote" != "$HOST" ]]  && return $?; }
  ### HOSTremote="" at this point means the remote function call returned a non-0 error code
  #
  local -a _arr
  #
  local __=""
  local _fn=""
  local _font=""
  local _fs=""
  local _fso=""
  local _geometry=""
  local _geometrycols=""
  local _geometryrows=""
  local _height=""
  local _i=
  local _in=""
  local _image=""
  local _info=""
  local _msg=""
  local _pad=""
  local _padlines=
  local _rc=
  local _stdin=""
  local _text=""
  local _tmpfile=""
  local _title=""
  local _width=""
  local _wrap=""
  local _yad_button_find=""
  local _yad_button_info=""
  local _yad_button_cancel=""
  local _yad_button_ok=""
  #
  _font="Mono 8"
  # _font="Fixed 10px"
  _fs=$'\@'; _fso="$IFS"; IFS="$NL"
  _tmpfile="$TMPDIR/$FUNCNAME"
  ### initialize
  #
  # export _pipe="$TMPDIR/${FUNCNAME}_pipe"; mkfifo $_pipe; exec 3<> $_pipe
  ### create ipc pipe
  ###   WAIT A MINUTE!
  ###     How do we remove this since it must stay around for yad dialog after kit has ended?
  #
  [[ "$1" =~ ^--                ]]  || _text="$1"
  [[ "$_text"                   ]]  || _text="$(optionArg --text "$@")"
  [[ "$_text"                   ]]  || _text="$(optionArg --     "$@")"
  [[ "$_text"                   ]]  || _text="$(inputStdin           )"
  ### if first arg is not '--text' assume is the --text argument
  #
  __="$(optionArg --stdin "$@")"    && _stdin="$(inputStdin)"
  ### accept multiline stdin, if any
  ### fractional values not supported till ver 4+ so must wait a whole second
  ### 20200426  if --stdin option, any stdin will be appended to _text and thus...
  ###     echo "hello" | kit dialog                         ### hello
  ###     echo "hello" | kit dialog --stdin                 ### hello
  ###     echo "hello" | kit dialog --stdin --text "big "   ### big hello
  #
  _msg="$_text$_stdin"
  ### message text to show is first non-option argument, followed by stdin if any
  #
  _fn="${FUNCNAME[1]}"; [[ "$_fn" =~ source|main ]]  || _fn+="()"
  ### 'source', 'main', or 'callingFunctionName' --> 'callingFunctionName()'
  #
  _title="$(optionArg --title "$@")"  || { _title="$TITLE ${FUNCNAME[1]}()"; }
  #
  _info="$(optionArg --more "$@")"    || { _info="kit $FUNCNAME --help"    ; }
  #
  _wrap="$(option --wrap "$@")"
  #
  _yad_button_info="gtk-info!2!Ctrl-S to Search for exact text${NL}  or${NL}Click button for...${NL}  $_info : $_info"
  _yad_button_cancel="gtk-cancel!1!Reject/No"
  _yad_button_ok="gtk-ok!0!Accept/Yes"
  ### yad buttons = icon ! rc ! tooltip : command
  #
  # _ARGS="$*"; inspVar --func
  #
  if isOption --middle "$@"
  then
    _lines="$(lineCount "$_msg")"
    #
    if (( _lines < GEOMETRY_CSH ))
    # if (( _lines < _helplinessm ))
    then
      _padlines=$(( ( GEOMETRY_CSH - _lines ) / 2 ))
      # _padlines=$(( ( $_helplinessm - $_lines ) / 2 ))
      #
      for ((i=0;i<_padlines;++i))
      do
        _pad+="$NL"
      done
    fi
  fi
  #
  _msg="$_pad$_msg$NL"
  ### vertically center short messages
  #
  if isOverflow "$_msg"
  then
    _geometry="$GEOMETRY_PL"
    _geometrycols="$GEOMETRY_CLW"
    _geometryrows="$GEOMETRY_CLH"
    ### large
  else
    _geometry="$GEOMETRY_PS"
    _geometrycols="$GEOMETRY_CSW"
    _geometryrows="$GEOMETRY_CSH"
    ### small
  fi
  ### use a small window if only a few lines
  #
  # _height="${_geometry#*x}"; _width="${_geometry%x*}";_width="${_width#-}"
  ### separate height and width for dialog command and zenity
  #
  # _ARGS="$*"; inspVar --func
  #
  case $UI in
    CLI)
      case "$DLG" in
        dialog)
          printf "%s\n" "$(printDecoded "$_msg")" > "$_tmpfile"
          #
          [[ "$_wrap" ]]  && { _wrap="--cr-wrap"; }
          #
          # inspVar _dialogcmd _wrap _tmpfile
          #
          # $_dialogcmd
          command dialog        \
            --title "$_title"   \
            --stdout            \
            $_wrap              \
            --textbox $_tmpfile $_geometryrows $_geometrycols
          ;;
        *)
          printf "%s" "$NL$_msg$NL$NL"  >&2
          ### print to terminal commandline with no padding
          ;;
      esac
      ;;
    GUI)
      case "$DLG" in
        yad*)
          printf "%s\n" "$(printDecoded "$_msg")" | yad \
            --text-info                                 \
            --display=":0"                              \
            --margins="$MARGINS"                        \
            --title="$_title"                           \
            --show-uri                                  \
            "$_wrap"                                    \
            --geometry="$_geometry"                     \
            --button="$_yad_button_info"                \
            --button="$_yad_button_cancel"              \
            --button="$_yad_button_ok"                  \
            --listen                                    \
            --fore="$HELPCOLORFG"                       \
            --back="$HELPCOLORBG"                       \
            --fontname="$HELPFONT"                      & ### in background
          ;;
        zenity*)
          ###
          ### Zenity 2.30.0 NOTE...
          ###   All input to 'zenity --text-info' is wrapped.
          ###   Some Zenity dialogs support a --no-wrap option
          ###   but --text-info does not.
          ###
          #
          _geometry="${_geometry#-}"
          ### strip off leading hyphen
          #
          printf "%s\n" "$(printDecoded "$_msg")" | DISPLAY=:0.0 zenity  \
            --text-info                                     \
            --display=":0"                                  \
            --title="$_title"                               \
            --height="${_geometry#*x}"                      \
            --width="${_geometry%x*}"                       & ### in background
          ;;
        *)
          abortDLG
          # printf "%s\n" "$_msg$NL"
          ;;
      esac
      ;;
    LOG)
      log --status "${NL}$(printAt 2 "$_msg")"
      ;;
    *)
      abortUI
  esac
  #
  IFS="$_fso"
  ### restore original IFS
  #
  return 0
}

# function dialogCheckDclick () {
#   fnInit ${FUNCNAME} "$@"  && return 0
#   #
#   inspArgShow "$@"
#   #
#   dialog --middle -- "$@"
#   # dialogShow --middle -- "echo $_cmd"
#   #
#   eval "$@"
# }

# function gtkList () {
#   fnInit ${FUNCNAME} "$@"  && return 0
#   #
#   local _editable=""
#   local _select=""
#   local _reply=""
#   local _msg=""
#   local -a _list
#   #
#   _editable="$(optionArg editable "$@")"  && { _editable="--editable"          ; }
#   #
#   readarray -t _list < <(optionArg '' "$@")
#   #
#   # inspVar _list
#   #
#   _msg="Select (enter item)? "
#   #
#   case $UI in
#     GUI)
#       case "$DLG" in
#         zenity*)
#           _select="$(zenity --list --display=":0" --title="$TITLE" --column="Select"      "$_editable" -- "$_list" &)" ### background
#           ### get selection
#           #
#           printf "%s" "${_select%|}"
#           ### remove separator
#           ;;
#         *)
#           abortDLG
#           ;;
#       esac
#       ;;
#     LOG)
#       log --status "$_msg"
#       ;;
#     *)
#       abortUI
#   esac
#   #
#   return $?
# }

function dialogCombo () {
  fnInit "$FUNCNAME.20190606" "$@"  && return 0
  #
  local _entrytext=""
  local _fs=""
  local _fso=""
  local _height=""
  local _label=""
  local _select=""
  local _selections_ct=
  local _text=""
  local _title=""
  local _width=""
  #
  local -a _selections
  local -a _dialog
  #
  _fs=$'\@'
  ### "field separator" (array item separator) must be something not in a value
  #
  _fso="$IFS"
  ### save original IFS for restoration when done
  #
  IFS="$NL"
  ### Input Field Separator is newline only (allows spaces and tabs within array items)
  #
  _title="$(    optionArg --title      "$@")"  || { _title="$TITLE:  ${FUNCNAME[1]}"; }
  #
  _text="$(     optionArg --text       "$@")"  || { _text="Enter value..."          ; }
  ### dialog text
  #
  _entrytext="$(optionArg --entry-text "$@")"  || { _entrytext="Select entry..."    ; }
  ### default selected item text
  #
  _label="$(    optionArg --label      "$@")"
  ### input field label
  #
  _width="700"
  ### fixed width of dialog
  #
  # printf "%s$NL" "$(optionArg -- "$@")"  >&2
  ### diagnostic
  #
  _selections=( $(optionArg -- "$@") $(inputStdin) )
  ### copy any piped input and/or positional arguments into _selections array for yad/zenity
  #
  _dialog=(
    yad --entry
      --display=":0"
      --width="$_width"
      --title="$_title"
      --text="$_text"
      --entry-label="$_label"
      --entry-text="$_entrytext"
  )
  ### initailize _dialog command array
  #
  # _selections_ct=${#_selections[@]}
  # _ARGS="$*"; inspVar --func _selections[@] _dialog[@]
  #
  case $UI in
    CLI)
      printf "%s$NL" "$_title"  >&2
      printAt 4 "$( printf "%s$NL" "${_selections[@]}" )"
      printf "        %s:  "    "$_label"  >&2; read _select; printf "$NL"  >&2
      ### from old gtkList
      ### use printf since read -p "prompt" does not print prompt realiably
      ### WARNING
      ###   This MAY not print the prompt if called inside command substitution ($(...))
      ;;
    GUI)
      case "$DLG" in
        yad*)
          _select="$( "${_dialog[@]}" -- $(printDecoded "${_selections[@]}") )"
          # _select="$( "${_dialog[@]}" -- "${_selections[@]}" )"
          ### get selection
          ;;
        zenity*)
          _select="$(
            zenity --entry                \
              --entry-text="$_entrytext"  \
              --display=":0"              \
              --width="$_width"           \
              --title="$_title"           \
              --text="$_text$NL$_label"   \
              "${_selections[@]}"         \
              &
          )" ### background
          # _select="$(zenity --list --display=":0" --title="$TITLE" --column="Select"      "$_editable" -- "$_list" &)" ### background
          # ### get selection
          # #
          # printf "%s" "${_select%|}"
          # ### remove separator
          ### from old gtkList
          ;;
        *)
          abortDLG
          ;;
      esac
      ;;
    *)
      abortUI
  esac
  #
  _select="${_select%|}"
  ### remove separator, if any
  #
  IFS="$_fso"
  ### restore normal IFS
  #
  [[ "$_select" == "$_entrytext" ]]  && {                            return 1; }
  ### Nothing explicitly selected (_entrytext is just a prompt)
  #
  [[ "$_select"                  ]]  && { printf "%s" "$_select"   ; return 0; }
  ### print host name entered and return success
  #
  return 1
  ### no host name entered so return failure
}

function  dialogConfirm () {
  fnInit "$FUNCNAME.20190903" "$@"  && return 0
  #
  local _bg=""
  local _fg=""
  local _fs=""
  local _fso=""
  local _geometry=""
  local _info=""
  local _reply=""
  local _text=""
  local _title=""
  #
  _bg="$(colorPref greyBackground)"; _bg="${_bg:-$HELPCOLORBG}"
  _fg="$(colorPref black         )"; _fg="${_fg:-$HELPCOLORFG}"
  _fs=$'\@'; _fso="$IFS"; IFS="$NL"
  #
  [[ "$1"                       ]]  || { "$FUNCNAME" --help; return 0; }
  ### if no arguments, show --help
  #
  [[ "$1" =~ ^--                ]]  || _text="$1"
  [[ "$_text"                   ]]  || _text="$(optionArg --text "$@")"
  # if first arg is not '--text' assume is the --text argument
  #
  [[ "$_text"                   ]]  || { abortShow unexpectedoption "First argument must be the question text"; return 1; }
  ### _text is required
  #
  _info="$( optionArg --info  "$@")"  || { _info=""                  ; }
  #
  _title="$(optionArg --title "$@")"  || { _title="$TITLE: $FUNCNAME"; }
  #
  IFS="$_fso"
  ### restore original IFS
  #
  case "$UI" in
    CLI)
      printf "$NL%s$NL$NL%s$NL$NL%s (y/N/q)? " "$_title" "$_info" "$_text" >&2; read _reply; printf "$NL" >&2
      ### Use printf since read -p "prompt" does not print prompt reliably
      ### Must redirect printf output to stderr so can be seen even if called
      ### from within Command Substitution $(...)
      #
      if [[ "$_reply" =~ [yY] ]]
      then
        return 0
      elif [[ "$_reply" =~ [qQ] ]]
      then
        returnCode 2; ___exit "$@"
      else
        return 1
      fi
      ;;
    GUI)
      if isOverflow "$_text"  ||  isOverflow "$_info"
      then
        _geometry="$GEOMETRY_PL"
      else
        _geometry="$GEOMETRY_PS"
      fi
      case "$DLG" in
        yad*)
          printf "%s\n" "$(printDecoded "$_info")" |
            yad --text-info                        \
              --text="$_text"                      \
              --display=":0"                       \
              --margins="$MARGINS"                 \
              --title="$_title"                    \
              --show-uri                           \
              --geometry="$_geometry"              \
              --fore="$_fg"                        \
              --back="$_bg"                        \
              --fontname="$HELPFONT"               \
              --button="gtk-quit:2"                \
              --button="gtk-cancel:1"              \
              --button="gtk-ok:0"                    ##modal (wait)
          ##long dialog popup
          #
          return $?
          ;;
        zenity*)
          printf "%s\n" "$(printDecoded "$_info")" | dialog
          ### dialog popup (1 of 2 windows since cannot control buttons)
          #
          zenity                                      \
            --question                                \
            --display=":0"                            \
            --title="$_title"                         \
            --text="$_text"                           ### modal (wait)
          ### dialog popup (2 of 2 windows since cannot control buttons)
          #
          return $?
          ;;
        *)
          abortDLG
          ;;
      esac
      ;;
    LOG)
      log --status "$_info"
      ;;
    *)
      ### CLI, etc
      ###
      ### WARNING
      ###   printf output to stdout does not print the prompt
      ###   if confirm() is called inside command substitution ( $(confirm ...) )
      ###   Printf MUST be redirected to &2 (stderr) to be seen on commandline.
      ###
      #
      printf "$NL%s$NL$NL%s$NL$NL%s (y/N/q)? " "$_title" "$_info" "$_text" >&2; read _reply; printf "$NL" >&2
      ### Use printf since read -p "prompt" does not print prompt realiably
      ### Must redirect printf output to stderr so can be seen even if called
      ### from within Command Substitution $(...)
      #
      if [[ "$_reply" =~ [yY] ]]
      then
        return 0
      elif [[ "$_reply" =~ [qQ] ]]
      then
        returnCode 2; ___exit "$@"
      else
        return 1
      fi
      # abortUI
      ;;
  esac
  #
  return 1
}

function dialogEntry () {
  fnInit "$FUNCNAME.20190908" "$@"  && return 0
  #
  local _title=""
  local _text=""
  local _label=""
  local _entry=""
  local _select=""
  local -a _yadopts
  #
  _title="$(optionArg --title "$@")"  || { _title="$TITLE:  ${FUNCNAME[1]}"; }
  #
  _label="$(optionArg --label "$@")"  || { _label="Entry: "                ; }
  #
  _text="$( optionArg --text  "$@")"  || { _text="Enter value..."          ; }
  #
  _entry="$(optionArg --      "$@")"  || { _entry=""                       ; }
  #
  _yadopts=( $(optionArg --yadopts "$@")    )
  _yadopts=( $(/usr/bin/printf "--%s " ${_yadopts[@]}) )
  ### allow yad options to be specified for special cases
  ### /usr/bin/printf required to allow the leading "--"
  #
  #
  # ARGS="$*"; inspVar --func
  #
  case $UI in
    CLI)
      _reply="n"
      while [[ "$_reply" =~ [nN] ]]
      do
        printf "$NL%s$NL$NL%s$NL$NL[%s]  %s$NL$NL%s (y/N/q)? " "$_title" "$_text" "$_label" "$_entry" "Is this correct? " >&2; read _reply; printf "$NL" >&2
        ### Use printf since read -p "prompt" does not print prompt reliably
        ### Must redirect printf output to stderr so can be seen even if called
        ### from within Command Substitution $(...)
        #
        case $_reply in
          [yY]) _select="$_entry"                               ; break;;
          [nN]) _entry="$(inputCli "[$_label] $_entry")"        ; continue;;
          [qQ]) _select=""                                      ; break;;
             *) _select=""                                      ; break;;
        esac
      done
      ;;
    GUI)
      case "$DLG" in
        yad*)
          _select="$(
            yad --entry                 \
              --text="$_text"           \
              --entry-label="$_label"   \
              --entry-text "$_entry"    \
              --display=":0"            \
              --title="$_title"         \
              --width=600               \
              --completion              \
              $_yadopts                 \
              --editable                ### modal
          )" ### background
          # _select="$(yad    --entry --entry-label="$_msg" --display=":0" --title="$_title" --editable -- "${_hosts[@]}" &)" ### background
          ### get selection
          ;;
        zenity*)
          _select="$(zenity --entry  --text="$_text$NL  ${_label}..."        --entry-text "$_entry" --display=":0" --title="$_title"  --width=600                         &)" ### background
          # _select="$(zenity --entry        --text="$_msg" --display=":0" --title="$_title" -- "${_hosts[@]}" &)" ### background
          ### get selection
          ;;
        *)
          abortDLG
          ;;
      esac
      ;;
    LOG)
      log --status "$_msg"
      ;;
    *)
      abortUI
  esac
  #
  _select="${_select%|}"
  ### remove separator, if any
  #
  [[ "$_select" ]]  && { printf "%s" "$_select"; return 0; }
  ### print host name entered and return success
  #
  return 1
  ### no host name entered so return failure
}

function dialogChecklist () {
  ###
  ### DERIVING FROM dialogSelect()
  ###
  fnInit "$FUNCNAME.20190407" "$@"  && return 0
  #
  local __=""                           ### temporary variable
  local _a=""
  local _dialogcmd=""
  local _divider=""
  local _colct=
  local _colopts=""
  local _coltip=""
  local _geometrycols=""
  local _geometryrows=""
  local _height=""
  local _multi=""
  local _nlopts=""
  local _pcol=""
  local _propts=""
  local _prompt=""
  local _rows=""
  local _select=""
  local _selection=""
  local _sep=""
  local _text=""
  local _title=""
  local _tmpfile=""
  local _width=""
  #
  local -i _i=
  local -i _cellsct=
  #
  local -a _COLNAMES
  local -a _colnames
  local -a _cells
  local -a _cells_dialog
  #
  _dialogcmd="$(which dialog)"
  _divider="---"
  _colct=1
  _colopts="--column=Select"
  _coltip="Ctrl-F and enter text to find first item beginning with text"
  _geometrycols="$GEOMETRY_CLW"
  _geometryrows="$GEOMETRY_CLH"
  _height="400"
  _nlopts="--number-format=rn --number-width=4 --starting-line-number=1"
  _pcol="0"
  _propts="--omit-pagination --across --page-width=100"
  _sep="|"
  _title="$TITLE:  ${FUNCNAME[1]}"
  _tmpfile="$TMPDIR/$FUNCNAME"
  _width="800"
  ### initialize variables
  #
  # log --allerrors
  #
  __="$(optionArg --title        "$@")"; _title="${__:-$_title}"
  __="$(optionArg --text         "$@")"; _text="${__:-$_text}"
  __="$(optionArg --print-column "$@")"; _pcol="${__:-$_pcol}"
  __="$(optionArg --separator    "$@")"  && { _sep="$__"; }
  __="$(optionArg --width        "$@")"; _width="${__:-$_width}"
  __="$(optionArg --column       "$@")"  && {
    __="$(sed "s/.*/--column=&/; s/\s/-/g" <<< "$__")"
    ### build YAD format --column options...
    ###   - [BUG] in YAD requires that whitespace be removed from column names
    ###     to prevent words after the first from being treated as list items
    ###   - Ouput separator/terminator...
    ###       No --separator option prints '|' after each column including the last
    ###       '--separator ""' option prints columns with no separators and no terminator
    #
    _colopts="${__:-$_colopts}"
  }
  ### PREVIOUS TECHNIQUES...
  # _title="$(optionArg --title        "$@")"  || { _title="$TITLE:  ${FUNCNAME[1]}"; }
  # _text="$( optionArg --text         "$@")"  || { _text="$_textdef"               ; }
  # _pcol="$( optionArg --print-column "$@")"  && { _pcol="--print-column=$_pcol"   ; }
  # _sep="$(  optionArg --separator    "$@")"  && { _sep="--separator=$_sep"        ; }
  # if _cols="$(optionArg --column "$@")"
  # then
  #   _colopts="$(sed "s/.*/--column=&/; s/\s//g" <<< "$_cols")"
  #   # _colopts="$(sed 's/.*/--column=&/' <<< "$_cols")"
  #   ### build YAD format --column options
  #   ###   [BUG] in YAD requires that whitespace be removed from column names
  #   ###   to prevent words after the first being treated as list items
  # else
  #   _colopts="--column=Select"
  # fi
  #
  _rows="$(optionArg -- "$@")"
  ### rows of data
  #
  while read _a; do [[ "$_a" ]]  && { _colnames+=("${_a#*=}"); }; done <<< "$_colopts"; _colct=${#_colnames[@]}
  # _colnames=( $_cols ); _colct=${#_colnames[@]}
  ### copy column names into array
  #
  while read _a; do [[ "$_a" ]]  && { _COLNAMES+=( $(printf "%s..." "${_a#*=}" | tr '[:lower:]' '[:upper:]') ); }; done <<< "$_colopts"
  # _COLNAMES=( $(printf "%q" "${_colnames[@]}" | tr '[:lower:]' '[:upper:]') )
  ### uppercase column names for CLI
  #
  if (( _colct == 1 ))
  then
    while read _a; do [[ "$_a" ]]  && { _cells+=("$_a"); }; done <<<"$_rows"; _cellsct=${#_cells[@]}
    ### copy selections into array for yad/zenity and count them
    ###   (must test for null _a to prevent creation of null array element)
  else
    _cells+=( $(awk '{print}' <<<"$_rows") ); _cellsct=${#_cells[@]}
  fi
  ### copy _rows into _cells array and save number of array elements as _cellsct
  #
  # _multi="$(optionArg --multiple "$@")"  && { _multi="--multiple"             ; }
  ### 20170424 [DISABLED]  Known GTK bugs(?) throws assertion failure...
  ###   (yad:19692): Gtk-CRITICAL **: gtk_tree_selection_get_selected: assertion `selection->type != GTK_SELECTION_MULTIPLE' failed
  #
  gtkSpinner --stop "$SPINNERPID"
  ### turn off spinner
  #
  # ARGS="$*"
  # inspVar ARGS _title _text _nlopts _propts _sep _pcol _colnames[@] _COLNAMES[@] _rows _colopts _colct \
  #         _dialogcmd _geometryrows _geometrycols _cells_dialog[@] _cells[@] _cellsct _selection _select
  #
  case $UI in
    CLI)
      _dialogcmd=""
      ### DISABLED due to bugs
      ###   20171118 by docsalvager
      if [[ "$_dialogcmd" ]]
      then
        _text="${_text}${NL}  (Mark 1 or more with [SPACEBAR] and select [Ok])"
        #
        _cells_dialog=( $(awk '{printf "\"%20s   [%s]\"",$3,$1}' <<<"$_rows") )
        ###
        ### Moved to inspectRevisions
        ###
        # _cells_dialog=( $(awk '{printf "%20s   [%s]",$3,$1}' <<<"$_rows") ) #<<< WORKS for dialogcmd
        #
        ##_cells_dialog=( $(awk '{print "[" $1 "]..." $3,"...","off"}' <<<"$_rows") )
        ##_cells_dialog=( $(awk '{print NR,"[" $1 "]..." $3,"off"}' <<<"$_rows") )
        ##_cells_dialog=( $(awk '{print NR,$3 ".[" $1 "]","off"}' <<<"$_rows") )
        ##_cells_dialog=( $(awk '{print NR,"\"" $3 "(" $1 ")\"","off"}' <<<"$_rows") )
        ##_cells_dialog=( $(awk '{print $3,$1,"off"}' <<<"$_rows") )
        # _cells_dialog=( "$(awk '{print NR,"\"" $3 "  " $2 "  " $1 "\"","off"}' <<< "$_rows")" )
        # _cells_dialog=( $(awk '{print NR,"\"" $3 "  " $2 "  " $1 "\"","off"}' "$_tmpfile") )
        ##_cells_dialog=( $(awk '{print $3,$1,"off"}' <<<"$_rows") )
        ##_cells_dialog=( $(awk '{print $1,$3,"off"}' <<<"$_rows") )
        # _cells_dialog=( $(gawk -F: '{print $0,"off"}' <<<"$_rows") )
        ##_cells_dialog=( 1 "aaa bbb ccc" off 2 "aaa bbb ccc" off )
        ##_cells_dialog=( "1" "aaa bbb ccc" "off" "2" "aaa bbb ccc" "off" )
        # _cells_dialog=( "$(awk '{print NR,"\"" $1 "  " $2 "  " $3 "\"","|" "off"}' <<<"$_rows")" )
        ##_cells_dialog=( "$(awk '{print NR,"|","\"" $1 "  " $2 "  " $3 "\"","|" "off"}' <<<"$_rows")" )
        # _cells_dialog=( "$(awk '{print NR,"|" "\"" $1 "  " $2 "  " $3 "\"" "|" "off"}' <<<"$_rows")" )
        # _cells_dialog=( "$(awk '{print NR,"\"" $1 "  " $2 "  " $3 "\"","off"}' <<<"$_rows")" )
        # _cells_dialog=( "$(awk '{print $1,"\"" $2 "  " $3 "\"","off"}' <<<"$_rows")" )
        ##_cells_dialog=( $_rows )
        # _cells_dialog=( "$(awk '{print "\""$0"\""}' <<<"$_rows")" )
        # _cells_dialog=( $(awk '{print NR,"\""$0"\"","off"}' <<<"$_rows") )
        #
        _selection="$(
          $_dialogcmd                 \
            --args                    \
            --clear                   \
            --stdout                  \
            --title "$_title"         \
            --menu                    \
              "$_text"                \
              $_geometryrows          \
              $_geometrycols          \
              $(($_geometryrows - 6)) \
            -- "${_cells_dialog[@]}"
        )"
      else
        ###
        ### --CLI --NODLG
        ###
        _text="${_text}${NL}  (Select by entering item number)"
        #
        _COLNAMES[0]=" ${_COLNAMES[0]}"
        ### adjust first column name to line up with numbered lines
        #
        while [[ ! "$_select" ]]
        do
          printf "$NL%s$NL$NL%s$NL$NL" "$_title" "$_text"  >&2
          #
          printf "%s$NL" "${_COLNAMES[@]}" | pr $_propts --columns=$_colct                >&2
          # printf "%s$NL" "${_COLNAMES[@]}" | pr $_propts --columns=$_colct | nl --body-numbering=n  >&2
          ### header
          #
          printf "%s$NL" "${_cells[@]}"    | pr $_propts --columns=$_colct | lineNumbers  >&2
          # printf "%s$NL" "${_cells[@]}"    | pr $_propts --columns=$_colct | nl $_nlopts            >&2
          ### body
          #
          # printf "$NL$NL[%s] " "Select"   >&2
          # printf "$NL$NL%s (y/N/q)? " "Is this correct? "   >&2
          #
          # read _reply; printf "$NL" >&2
          ### Use printf since read -p "prompt" does not print prompt reliably
          ### Must redirect printf output to stderr so can be seen even if called
          ### from within Command Substitution $(...)
          #
          printf "$NL$NL"  >&2
          #
          # printf "%s" "[Select by number, enter new, or (q)uit] "
          #
          _select="$(inputCli "[Select by number, enter new, or (q)uit]  ")"
          # _select="$(inputCli)"
          # _select="$(cliInput "[Select by number, enter new, or (q)uit]  " "$_select")"
          #
          [[ "$_select" =~ ^[qQ]$  ]]  && {                                                      break; }
          ### quit
          #
          [[ "$_select" =~ ^[^0-9] ]]  && { _cells+=("$_select"); _select=""; ((++_cellsct)); continue; }
          ### enter new selection
          #
          if (( $_select > 0 ))
          then
            #
            # inspVar _select _cells[0]
            #
            _select=$((--_select))
            _select=$((_select*_colct))
            #
            # inspVar _colct _select _cells[$_select]
            #
            _selection=""
            if (( _select < _cellsct ))
            then
              for (( _i=0; _i<_colct; ++_i ))
              do
                _selection+="$(printf "%s|" "${_cells[((_select+_i))]}")"
                # _selection="$(printf "%s|" "${_cells[((_select+0))]}" | tr ' ' '|')"
              done
            else
              _select=""
            fi
            ### use selection number __
          else
            _select=""
          fi
          #
          [[ "$_select" ]]  || { errorShow invalidinput "Must select an item between 1 and $(( _cellsct / _colct ))"; } ### loop again
        done
      fi
      ;;
    GUI)
      _text="${_text}${NL}(Click item to select and then click [OK] button)${NL}[$_coltip]"
      #
      case "$DLG" in
        yad*)
          _pcol="${_pcol/ALL/0}"
          ### zenity default:  --print-column=ALL
          ###    yad default:  --print-column=0    (meaning ALL)
          #
          [[ "${_cells}" ]]  || { _cells=(""); }
          ### prime with a blank selection if there are none so it can be edited
          #
          _selection="$(
            yad --list                \
              --display=":0"          \
              --editable              \
              --expand-column=0       \
              --height="$_height"     \
              --print-column="$_pcol" \
              --search-column=1       \
              --selectable-labels     \
              --separator="$_sep"     \
              --text="$_text"         \
              --title="$_title"       \
              --width="$_width"       \
              $_colopts               \
              $_multi                 \
              -- "${_cells[@]}"       \
          )"
          ### get selection
          ### waits for input so not backgrounded (20170424)
          ;;
        zenity*)
          [[ "${_cells}" ]]  || { _cells=(""); }
          ### prime with a blank selection if there are none so it can be edited
          #
          _pcol="${_pcol/0/ALL}"
          ### zenity default:  --print-column=ALL
          ###    yad default:  --print-column=0    (meaning ALL)
          #
          _selection="$(
            zenity --list             \
              --display=":0"          \
              --editable              \
              --height="$_height"     \
              --print-column="$_pcol" \
              --separator="$_sep"     \
              --text="$_text"         \
              --title="$_title"       \
              --width="$_width"       \
              $_colopts               \
              $_multi                 \
              -- "${_cells[@]}"       \
          )"
          ### get selection
          ### waits for input so not backgrounded (20170424)
          ;;
        *)
          abortDLG
          ;;
      esac
      ;;
    *)
      abortUI
  esac
  #
  # ARGS="$*"
  # inspVar ARGS _title _text _nlopts _propts _sep _pcol _colopts _colct _colnames[@] _COLNAMES[@] _rows \
  #         _dialogcmd _geometryrows _geometrycols _cells_dialog[@] _cells[@] _cellsct _selection _select
  #
  [[ "$_selection" ]]  && { printf "%s$NL" "$_selection"; return 0; }
  # [[ "$_selection" ]]  && { printf "%s" "$_selection"; return 0; }
  ### print selection(s) and return success
  #
  return 1
  ### nothing entered or selected so return failure
}

function dialogSelect () {
  fnInit "$FUNCNAME.20190923" "$@"  && return 0
  #
  local __=""                           ### temporary variable
  local _a=""
  local _colct=
  local _coltip=""
  local _dialogcmd=""
  local _divider=""
  local _fs=""
  local _fso=""
  local _geometrycols=""
  local _geometryrows=""
  local _height=""
  local _multi=""
  local _nlopts=""
  local _pcol=""
  local _prompt=""
  local _rows=""
  local _select=""
  local _selection=""
  local _sep=""
  local _text=""
  local _title=""
  local _tmpfile=""
  local _width=""
  #
  local -i _i=
  local -i _cellsct=
  local -a _propts=
  #
  local -a _COLNAMES
  local -a _colnames
  local -a _cells
  local -a _cells_dialog
  #
  _colct=1
  _colopts=( "--column=Select" )
  _coltip="Find: Ctrl-F, More Options:  right-click"
  _fs=$'\@'; _fso="$IFS"; IFS="$NL"
  _dialogcmd="$(which dialog)"
  _divider="---"
  _geometrycols="$GEOMETRY_CLW"
  _geometryrows="$GEOMETRY_CLH"
  _height="400"
  _nlopts="--number-format=rn --number-width=4 --starting-line-number=1"
  _pcol="0"
  _propts=( --omit-pagination --across --page-width=100 )
  # _propts="--omit-pagination --across --page-width=100"
  _sep="|"
  _title="$TITLE:  ${FUNCNAME[1]}"
  _tmpfile="$TMPDIR/$FUNCNAME"
  _width="800"
  ### initialize variables
  #
  # log --allerrors
  #
  SPINNERPID="$(gtkSpinner --tip "$FUNCNAME()")"
  ### start busy spinner and save the pid
  #
  __="$(optionArg --title        "$@")"; _title="${__:-$_title}"
  __="$(optionArg --text         "$@")"; _text="${__:-$_text}"
  __="$(optionArg --print-column "$@")"; _pcol="${__:-$_pcol}"
  __="$(optionArg --height       "$@")"; _height="${__:-$_height}"
  __="$(optionArg --width        "$@")"; _width="${__:-$_width}"
  __="$(optionArg --separator    "$@")"  && { _sep="$__"; }
  __="$(optionArg --column       "$@")"  && {
    _colnames=( "$__" )
    ### set column names to --column option arguments
  }
  # __="$(optionArg --column       "$@")"  && {
  #   __="$(sed "s/.*/--column=&/; s/\s/-/g" <<< "$__")"
  #   ### build YAD format --column options...
  #   ###   - [BUG] in YAD requires that whitespace be removed from column names
  #   ###     to prevent words after the first from being treated as list items
  #   ###   - Output separator/terminator...
  #   ###       No --separator option prints '|' after each column including the last
  #   ###       '--separator ""' option prints columns with no separators and no terminator
  #   #
  #   _colopts="${__:-$_colopts}"
  # }
  ### PREVIOUS TECHNIQUES...
  # _title="$(optionArg --title        "$@")"  || { _title="$TITLE:  ${FUNCNAME[1]}"; }
  # _text="$( optionArg --text         "$@")"  || { _text="$_textdef"               ; }
  # _pcol="$( optionArg --print-column "$@")"  && { _pcol="--print-column=$_pcol"   ; }
  # _sep="$(  optionArg --separator    "$@")"  && { _sep="--separator=$_sep"        ; }
  # if _cols="$(optionArg --column "$@")"
  # then
  #   _colopts="$(sed "s/.*/--column=&/; s/\s//g" <<< "$_cols")"
  #   # _colopts="$(sed 's/.*/--column=&/' <<< "$_cols")"
  #   ### build YAD format --column options
  #   ###   [BUG] in YAD requires that whitespace be removed from column names
  #   ###   to prevent words after the first being treated as list items
  # else
  #   _colopts="--column=Select"
  # fi
  #
  _rows="$(optionArg -- "$@" | sort)"
  ### rows of data
  #
  # _ARGS="$*"; inspVar --func _cells[@] _colnames[@] _colopts[@]
  ### diagnostic
  #
  while read _a; do [[ "$_a" ]]  && { _colnames+=("${_a#*=}"); }; done <<< "$_colopts"; _colct=${#_colnames[@]}
  # _colnames=( $_cols ); _colct=${#_colnames[@]}
  ### copy column names into array
  #
  while read _a; do [[ "$_a" ]]  && { _COLNAMES+=( $(printf "%s..." "${_a#*=}" | tr '[:lower:]' '[:upper:]') ); }; done <<< "$_colopts"
  # _COLNAMES=( $(printf "%q" "${_colnames[@]}" | tr '[:lower:]' '[:upper:]') )
  ### uppercase column names for CLI
  #
  if (( _colct == 1 ))
  then
    while read _a; do [[ "$_a" ]]  && { _cells+=("$_a"); }; done <<<"$_rows"; _cellsct=${#_cells[@]}
    ### copy selections into array for yad/zenity and count them
    ###   (must test for null _a to prevent creation of null array element)
  else
    _cells+=( $(awk '{print}' <<<"$_rows") ); _cellsct=${#_cells[@]}
  fi
  ### copy _rows into _cells array and save number of array elements as _cellsct
  #
  # _multi="$(optionArg --multiple "$@")"  && { _multi="--multiple"             ; }
  ### 20170424 [DISABLED]  Known GTK bugs(?) throws assertion failure...
  ###   (yad:19692): Gtk-CRITICAL **: gtk_tree_selection_get_selected: assertion `selection->type != GTK_SELECTION_MULTIPLE' failed
  #
  gtkSpinner --stop "$SPINNERPID"
  ### turn off spinner
  #
  case $UI in
    CLI)
      _dialogcmd=""
      ### DISABLED due to bugs
      ###   20171118 by docsalvager
      if [[ "$_dialogcmd" ]]
      then
        _text="${_text}${NL}  (Mark 1 or more with [SPACEBAR] and select [Ok])"
        #
        _cells_dialog=( $(awk '{printf "\"%20s   [%s]\"",$3,$1}' <<<"$_rows") )
        ###
        ### Moved to inspectRevisions
        ###
        # _cells_dialog=( $(awk '{printf "%20s   [%s]",$3,$1}' <<<"$_rows") ) #<<< WORKS for dialogcmd
        #
        ##_cells_dialog=( $(awk '{print "[" $1 "]..." $3,"...","off"}' <<<"$_rows") )
        ##_cells_dialog=( $(awk '{print NR,"[" $1 "]..." $3,"off"}' <<<"$_rows") )
        ##_cells_dialog=( $(awk '{print NR,$3 ".[" $1 "]","off"}' <<<"$_rows") )
        ##_cells_dialog=( $(awk '{print NR,"\"" $3 "(" $1 ")\"","off"}' <<<"$_rows") )
        ##_cells_dialog=( $(awk '{print $3,$1,"off"}' <<<"$_rows") )
        # _cells_dialog=( "$(awk '{print NR,"\"" $3 "  " $2 "  " $1 "\"","off"}' <<< "$_rows")" )
        # _cells_dialog=( $(awk '{print NR,"\"" $3 "  " $2 "  " $1 "\"","off"}' "$_tmpfile") )
        ##_cells_dialog=( $(awk '{print $3,$1,"off"}' <<<"$_rows") )
        ##_cells_dialog=( $(awk '{print $1,$3,"off"}' <<<"$_rows") )
        # _cells_dialog=( $(gawk -F: '{print $0,"off"}' <<<"$_rows") )
        ##_cells_dialog=( 1 "aaa bbb ccc" off 2 "aaa bbb ccc" off )
        ##_cells_dialog=( "1" "aaa bbb ccc" "off" "2" "aaa bbb ccc" "off" )
        # _cells_dialog=( "$(awk '{print NR,"\"" $1 "  " $2 "  " $3 "\"","|" "off"}' <<<"$_rows")" )
        ##_cells_dialog=( "$(awk '{print NR,"|","\"" $1 "  " $2 "  " $3 "\"","|" "off"}' <<<"$_rows")" )
        # _cells_dialog=( "$(awk '{print NR,"|" "\"" $1 "  " $2 "  " $3 "\"" "|" "off"}' <<<"$_rows")" )
        # _cells_dialog=( "$(awk '{print NR,"\"" $1 "  " $2 "  " $3 "\"","off"}' <<<"$_rows")" )
        # _cells_dialog=( "$(awk '{print $1,"\"" $2 "  " $3 "\"","off"}' <<<"$_rows")" )
        ##_cells_dialog=( $_rows )
        # _cells_dialog=( "$(awk '{print "\""$0"\""}' <<<"$_rows")" )
        # _cells_dialog=( $(awk '{print NR,"\""$0"\"","off"}' <<<"$_rows") )
        #
        _selection="$(
          $_dialogcmd                 \
            --args                    \
            --clear                   \
            --stdout                  \
            --title "$_title"         \
            --menu                    \
              "$_text"                \
              $_geometryrows          \
              $_geometrycols          \
              $(($_geometryrows - 6)) \
            -- "${_cells_dialog[@]}"
        )"
      else
        ###
        ### --CLI --NODLG
        ###
        _text="${_text}${NL}  (Select by entering item number)"
        #
        _COLNAMES[0]=" ${_COLNAMES[0]}"
        ### adjust first column name to line up with numbered lines
        #
        while [[ ! "$_select" ]]
        do
          printf "$NL%s$NL$NL%s$NL$NL" "$_title" "$_text"  >&2
          #
          printf "%s$NL" "${_COLNAMES[@]}" | pr "${_propts[@]}" --columns=$_colct                >&2
          # printf "%s$NL" "${_COLNAMES[@]}" | pr $_propts --columns=$_colct | nl --body-numbering=n  >&2
          ### header
          #
          printf "%s$NL" "${_cells[@]}"    | pr "${_propts[@]}" --columns=$_colct | lineNumbers  >&2
          # printf "%s$NL" "${_cells[@]}"    | pr $_propts --columns=$_colct | nl $_nlopts            >&2
          ### body
          #
          # printf "$NL$NL[%s] " "Select"   >&2
          # printf "$NL$NL%s (y/N/q)? " "Is this correct? "   >&2
          #
          # read _reply; printf "$NL" >&2
          ### Use printf since read -p "prompt" does not print prompt reliably
          ### Must redirect printf output to stderr so can be seen even if called
          ### from within Command Substitution $(...)
          #
          printf "$NL$NL"  >&2
          #
          # printf "%s" "[Select by number, enter new, or (q)uit] "
          #
          _select="$(inputCli "[Select by number, enter new, or (q)uit]  ")"
          # _select="$(inputCli)"
          # _select="$(cliInput "[Select by number, enter new, or (q)uit]  " "$_select")"
          #
          [[ "$_select" =~ ^[qQ]$  ]]  && {                                                      break; }
          ### quit
          #
          [[ "$_select" =~ ^[^0-9] ]]  && { _cells+=("$_select"); _select=""; ((++_cellsct)); continue; }
          ### enter new selection
          #
          if (( $_select > 0 ))
          then
            #
            # inspVar _select _cells[0]
            #
            _select=$((--_select))
            _select=$((_select*_colct))
            #
            # inspVar _colct _select _cells[$_select]
            #
            _selection=""
            if (( _select < _cellsct ))
            then
              for (( _i=0; _i<_colct; ++_i ))
              do
                _selection+="$(printf "%s|" "${_cells[((_select+_i))]}")"
                # _selection="$(printf "%s|" "${_cells[((_select+0))]}" | tr ' ' '|')"
              done
            else
              _select=""
            fi
            ### use selection number __
          else
            _select=""
          fi
          #
          [[ "$_select" ]]  || { errorShow invalidinput "Must select an item between 1 and $(( _cellsct / _colct ))"; } ### loop again
        done
      fi
      ;;
    GUI)
      _text="${_text}${NL}(Click item to select and then click [OK] button)${NL}[$_coltip]"
      #
      case "$DLG" in
        yad*)
          _pcol="${_pcol/ALL/0}"
          ### zenity default:  --print-column=ALL
          ###    yad default:  --print-column=0    (meaning ALL)
          #
          [[ "${_cells}" ]]  || { _cells=(""); }
          ### prime with a blank selection if there are none so it can be edited
          #
          _selection="$(
            printf "%s\n" "$(printDecoded "${_cells[@]}")" |
              yad --list                 \
                --display=":0"           \
                --editable               \
                --expand-column=0        \
                --height="$_height"      \
                --print-column="$_pcol"  \
                --search-column=1        \
                --separator="$_sep"      \
                --text="$_text"          \
                --title="$_title"        \
                --width="$_width"        \
                --no-markup              \
                $_colopts
          )"
          #
          # --selectable-labels      \
          ### BUG in yad that causes label to be pre-selected when this option is enabled
          ###   20190508  After several days of experimentation, no workaround found.
          ###             See also ~/.config/gtk-3.0/gtk.css.
          ###             Submitted Issue #45 at https://github.com/v1cont/yad/issues
          ###
          ### get selection
          ### waits for input so not backgrounded (20170424)
          ;;
        zenity*)
          [[ "${_cells}" ]]  || { _cells=(""); }
          ### prime with a blank selection if there are none so it can be edited
          #
          _pcol="${_pcol/0/ALL}"
          ### zenity default:  --print-column=ALL
          ###    yad default:  --print-column=0    (meaning ALL)
          #
          _selection="$(
            zenity --list             \
              --display=":0"          \
              --editable              \
              --height="$_height"     \
              --print-column="$_pcol" \
              --separator="$_sep"     \
              --text="$_text"         \
              --title="$_title"       \
              --width="$_width"       \
              $_colopts               \
              $_multi                 \
              -- "${_cells[@]}"       \
          )"
          ### get selection
          ### waits for input so not backgrounded (20170424)
          ;;
        *)
          abortDLG
          ;;
      esac
      ;;
    *)
      abortUI
  esac
  #
  IFS="$_fso"
  ### restore original IFS
  #
  [[ "$_selection" ]]  && { printf "%s$NL" "$_selection"; return 0; }
  # [[ "$_selection" ]]  && { printf "%s" "$_selection"; return 0; }
  ### print selection(s) and return success
  #
  return 1
  ### nothing entered or selected so return failure
}

function dialogShow () { aliasOf dialog "$@"; }

function dirClose () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _dir="$(optionArg '' "$@")"
  ### directory is first non-option argument
  #
  # inspVarShow _dir
  #
  if isNotNull "$_dir"
  then
    isOption purge "$@"  && { rm --force --recursive $_dir  ; return $?; }
    #
    isOption empty "$@"  && { rm --force --recursive $_dir/*; return $?; }
    #
    return 0
    ### no option: leave directory and contents intact
  else
    abortShow argumentnotfound "No directory name supplied"
    ### abort
  fi
}

function dirModified () {
  fnInit "$FUNCNAME.20190421" "$@"  && return 0
  #
  local __=""
  local _action=""
  local _cache=""
  local _datetime=""
  local _dir=""
  local _errormsg=""
  local _file=""
  local _i=""
  local _path=""
  local _pid=""
  local _start=""
  local _stop=""
  local _stopprocs=""
  local _title=""
  #
  _cache="${HOMEDIR}/cache/$FUNCNAME"
  _datetime="$(date +%Y%m%d-%H%M%S)"
  _errmsg_noinotifywait="Function $FUNCNAME requires inotifywait from the inotify-tools package"
  _errmsg_nostart="'$FUNCNAME --start' directory missing"
  _title="$TITLE.$FUNCNAME()"
  ### initialize
  #
  which inotifywait >/dev/null 2>&1  || { abortShow filenotfound "$_errmsg_noinotifywait"; }
  ### depends on inotifywait command
  #
  [[ "$1" =~ ^-- ]]  || _dir="$1"
  ### if first arg is not an option, assume it to be the directory monitored
  #
  __="$(optionArg --start "$@")"  && { _start="${__:-$_dir}"; [[ "$_start" ]] || { abortShow filenotfound "$_errmsg_nostart"; }; }
  ### support 'dir --start' and '--start dir' and require a directory name
  #
  __="$(optionArg --stop  "$@")"  && {  _stop="${__:-$_dir}"; _stop="${_stop:-*}"; }
  ### support 'dir --stop' and '--stop dir' and default to all processes if none supplied
  #
  [[ "$_stop" ]]  && {
    [[ "$_stop" = "*" ]]  && { _stop=""; }
    ### clear _stop so all inotifywait processes will be returned
    #
    _stopprocs="$(psgrep --search "inotifywait --monitor $_stop" --exclude "\--stop")"
    #
    dialogConfirm --text "Kill these processes?" --info "$_stopprocs" --title "$_title"  && {
      _stopprocs="$(echo "$(awk '{print $2}' <<< "$_stopprocs")")"
      #
      [[ "$_stopprocs" ]]  && { kill -9 $_stopprocs; }
    }
    #
    return 1
  }
  ### stop all inotifywait processes monitoring a given directory
  #
  ### --start is the default
  inotifywait --monitor "$_start" --event create --event moved_to --event modify |
    while read _path _action _file
    do
      echo "$_datetime  $_action  $_path$_file"  >>"$_cache"
      #
      # echo "The file '$_file' appeared in directory '$_path' via '$_action' and was added to '$_cache'"
    done                                                      & ### backgrounded
  ### start inotifywait process monitoring a given directory
  #
  return $?
}

function dirOpen () {
  fnInit "$FUNCNAME.20190911" "$@"  && return 0
  #
  local _msg=""
  local _par=""
  local _path=""
  local _dir=""
  local _targ=""
  local _targerr=
  local _rc=
  #
  local _link
  local _linkdir
  local _linkpath
  local _linkrel
  local _linkgood=0
  local _linknull=1
  local _linknone=2
  local _linkbroke=3
  #
  [[ "$1"                           ]]  || { "$FUNCNAME" --help; return 0; }
  ### if no arguments, show --help
  #
  [[ "$1" =~ ^-- ]]  || _dir="$1"
  [[ "$_dir"     ]]  || _dir="$(optionArg --dir "$@")"
  ### if first arg is not an option, assume it to be the directory to create
  #
  # _dir="$(optionArg --:1 "$@")"
  # # _dir="$(argNonOption 1 "$@")"
  # ### directory path is first positional(nonoption) argument
  #
  _path="$(pathStr --path "$_dir")"
  _targ="$(linkTarget     "$_path")"; _targerr=$?
  #
  # _ARGS="$*"; inspVar --func
  #
  case $_targerr in
    0)  isDirWrite "$_targ"  && { printf "${_path}\n"; return 0; }
        ### already exists and is writable so return
        #
        _msg="Target of link found but not writable...$NL"
        _msg+="    Link->:  $_path$NL"
        _msg+="    Target:  $_targ$NL"
        abortShow accessdenied "$_msg"
        ### inaccessible so abort
        ;;
    1)  abortShow filenotfound "Missing directory:  $_dir"
        ### _path is null or does not exist
        ;;
    2)  :
        ### _path is not a link so continue processing below
        ;;
    3)  [[ "$_targ" ]]  && { _path="$(pathStr --path "$_targ")"; }
        ### broken link so create the target directory instead
        ;;
    *)  abortShow operationfailed "Unknown error - linkTarget() returned error $_targerr"
        ### unknown error
        ;;
  esac
  ### get full, absolute path to dir via a link
  #
  _par="$(pathStr --dir  "$_path")"
  ### parent directory
  #
  if _link="$(optionArg --link "$@")"
  then
    _linkpath="$(pathStr --path "$_link")"
    _linkrel="$( pathRelativePy $_linkpath $_path)"
    ### DO NOT MAKE ABSOLUTE
  fi
  #
  isDirWrite "$_path"   && { printf "${_path}\n"; return 0; }
  ### file already exists and is writable so return
  #
  if mkdir --parents "$_path"
  ### create directory (and any parents required)
  then
    [[ "$_linkpath" ]]  && { ln -sf "$_path" "$_linkpath"; }
    ### recreate absolute link (forced)
    #
    printf "${_path}\n"
    return 0
  else
    abortShow operationfailed "Unable to open directory: ${_path} ${NL}${NL}( more at ${_logfile}... )"
    return 1
  fi
}

function errorShow () {
  fnInit "$FUNCNAME.20180208" "$@"  && return 0
  #
  local _fn="${FUNCNAME[1]}"
  local _title="$TITLE: Error"
  local _cause=""
  local _causedef="unspecified"
  local _causetext=""
  local _metafile="$METAFILE"
  local _topicvar="errorShow_help"
  local _topictext=""
  local _comment=""
  local _msg=""
  #
  [[ "$_fn" =~ abortShow        ]]  && { _fn="${FUNCNAME[2]}"              ; }
  ### if called by abortShow(), use its caller instead
  #
  [[ "$1" =~ ^--                ]]  || { _cause="$1"                       ; }
  [[ "$_cause"                  ]]  || { _cause="$(optionArg --cause "$@")"; }
  [[ "$_cause"                  ]]  || { _cause="$_causedef"               ; }
  # _cause="$(optionArg --:1 "$@")"  || { _cause="$_causedef" ; }
  ### if first arg is not an option, assume is the --cause option argument
  ###   This will be the topic code string for the error
  #
  [[ ! "$1" =~ ^-- ]]  && [[ ! "$2" =~ ^-- ]]  && _comment="$2"
  [[ "$_comment"                           ]]  || _comment="$(optionArg --comment "$@")"
  # _comment="$(optionArg --:2 "$@")"
  # _comment="$(argNonOption 2 "$@")"
  # _comment="$(argNonOption 2 "$@")"  && { _comment="$(printAt 4 "$_comment")"; }
  ### if neither first nor second argument is an option, assume 2nd arg is the --comment option argument
  ###   A SPECIAL CASE FOR BACKWARD COMPATIBILITY
  #
  _topictext="$(varFind "$_topicvar" --metafile "$_metafile")"
  ### errorShow help
  #
  _causetext="$(topic "$_cause" "$_topictext")"  || {
    _causetext="$(topic "$_causedef" "$_topictext")"  || {
      _causetext="Unknown cause"
    }
  }
  ### Get topic text out of errorShow_help string. To add a new topic, just add
  ### text under "Topics:" in the help text above. No other code is required.
  #
  _msg+="${NL}${_fn}()$NL$NL"
  _msg+="$(printAt 4 "${_causetext}")$NL$NL"
  _msg+="$(printAt 8 "${_comment}")$NL"
  # _msg+="${NL}${_fn}()$NL$NL    ${_causetext}$NL$NL        ${_comment}$NL"
  #
  # local _err=$?
  # _msg+="${NL}printAt result code: $_err"
  #
  # _ARGS="$*"; inspVar --func LOGFILE
  #
  dialog --title="$_title" -- "${_msg}"
  #
  return 0
}

function fan () {
  fnInit ${FUNCNAME} "$@" && return 0
  #
  [[ "$1" ]]  || { "$FUNCNAME" --help; return 0; }
  ### if no arguments, show --help
  #
  local _cmd="$1"
  local _msg=""
  local _dev="/proc/acpi/toshiba/fan"
  #
  isFileRead "$_dev"                                         || { errorShow filenotfound "$_dev"; return 1; }
  #
  case $_cmd in
    status)
      _msg="$(IFS=$'\n'; printf "fan   %s\n" $(cat $_dev))"  && { printf "%s$NL" "$_msg"; return 0; }
      ;;
    start)
      _msg="$(echo 'force_on:1' 2>/dev/null 1>"$_dev")"      && { printf "%s$NL" "$_msg"; return 0; }
      ;;
    stop)
      _msg="$(echo 'force_on:0' 2>/dev/null 1>"$_dev")"      && { printf "%s$NL" "$_msg"; return 0; }
      ;;
    *)
      "$FUNCNAME" --help                                                                ; return 0
      ;;
  esac
}

function thermal () {
  fnInit ${FUNCNAME} "$@" && return 0
  #
  [[ "$1" ]]  || { "$FUNCNAME" --help; return 0; }
  ### if no arguments, show --help
  #
  local _cmd="$1"
  local _msg=""
  local _dev="/proc/acpi/thermal_zone/THRM"
  #
  isFileRead "$_dev"                                                       || { errorShow filenotfound "$_dev"; return 1; }
  #
  case $_cmd in
    status)
      _msg="$(fan status; IFS=$'\n'; printf "therm %s\n" $(cat $_dev/*))"  && { printf "%s$NL" "$_msg"; return 0; }
      ;;
    *)
      "$FUNCNAME" --help                                                                              ; return 0
      ;;
  esac
}

### What is this?
###   _path & _file not set before use
#
# function fileCopies () {
#   fnInit ${FUNCNAME} "$@"  && return 0
#   #
#   local -a _sources
#   local -a _targets
#   local _s=""
#   local _t=""
#   #
#   [[ "$1"                           ]]  || { "$FUNCNAME" --help; return 0; }
#   ### if no arguments, show --help
#   #
#   isFileExists "$_path/$_file"      && { readarray -t _list < $_path/$_file; }
#   ### read in stored commands
#   #
#   _sources=( $(optionArg sources "$@") )  || { "$FUNCNAME" --help; return 0; }
#   #
#   _targets=( $(optionArg targets "$@") )  || { "$FUNCNAME" --help; return 0; }
#   #
#   inspVar _sources _targets
#   #
#   # printf "%s\n" "$(awk '{ print "\"" $0 "\"" }' <<<$_sources)"
#   # _sources="$(sed "s/^.*$/\"&\"/g" <<<"$_sources")"
#   #
#   # _targets="$(sed "s/^.*$/\'&\'/g" <<<"$_targets")"
#   #
#   inspVar _sources _targets
#   #
#   # set -- $_sources
#   for _s in ${_sources[@]}
#   do
#     # set -- $_targets
#     for _t in ${_targets[@]}
#     do
#       # [[ "$_s" =~ \s ]]  && { echo "source '$_sources' contains spaces"; continue; }
#       echo "cp $_s $_t"
#       # cp "$_s" "$_t"
#     done
#   done
#   #
#   return $?
# }

###
### see script psgrep
###
# function psgrep () {
#   fnInit ${FUNCNAME} "$@"  && return 0
#   #
#   local _search=""
#   local _exclude=""
#   local _results=""
#   #
#   [[ "$1" =~ ^-- ]]  || _search="$1"
#   [[ "$_search"  ]]  || _search="$(optionArg --search "$@")"
#   ### if first arg is not an option, assume it to be the directory to monitor
#   #
#   _exclude="$(optionArg --exclude "$@")"
#   ### also exclude processes containing this text
#   #
#   # ARGS="$*"; inspVar ARGS _search _exclude _results
#   #
#   # ps -f | head -n 1
#   ### Display heading only since grep will strip it off below
#   #
#   _results="$(ps -ef | grep -E "$_search" | grep -v 'grep')"
#   ### List all process, select lines containing $1, exclude grep and optional text
#   #
#   [[ "$_exclude" ]]  && { _results="$(grep -v "$_exclude" <<< "$_results")"; }
#   ### optional excludes
#   #
#   # ARGS="$*"; inspVar ARGS _search _exclude _results
#   #
#   printf "%s$NL" "$_results"
#   #
#   return $?
# }


function fileClose () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _file=""
  #
  _file="$(optionArg --:1 "$@")"
  # _file="$(argNonOption 1 "$@")"
  ### Positional argument is directory name
  #
  # ARGS="$*"; inspVar ARGS _file
  #
  if isNotNull "$_file"
  then
    isOption empty "$@"  && {           >$_file; }
    ### --empty replaces the file with an empty one
    #
    isOption purge "$@"  && { rm --force $_file; }
    ### --purge deletes the file
    #
    ### no option: leave file intact
    #
    return 0
  else
    abortShow argumentnotfound "No file name supplied"
  fi
}

function fileEdit () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _sedcmd="sed --regexp-extended -print"
  local _findcmd="find -exec \$_sedcmd '{}' +"
  #
  [[ "$@" ]]  || { $FUNCNAME --help; return 0; }
  ### no options so show help
  #
  $_findcmd "$@"
  #
  return $?
}

function fileFind () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _cmd=""
  local _in=""
  local _name=""
  local _maxdepth=""
  #
  # local _args=("$@")
  ### local working copy of arguments
  #
  [[ "$@" ]]  || { $FUNCNAME --help; return 0; }
  ### no options so show help
  #
  [[ "$1" == "--find" ]]  && { find "${@:2}"                      ; return $?; }
  ### pass all remaining arguments to 'find' command
  #
  #
  _cmd="find -L"
  ### always follow symlinks
  ###   WARNING:  Watch out for circular references
  #
  isOption --recursive "$@"  || { _maxdepth=" -maxdepth 1"; }
  ### search only given dir unless --recursive
  #
  #
  _in="$(optionArg --in "$@")"
  #
  [[ "$_in" =~ \s ]]  && { _in="'${_in}'"; }
  ### quote argument if it contains spaces
  #
  [[ "$_in" ]]  && { _cmd+=" $_in"; }
  # [[ "$_in" ]]  && { _cmd+=" \"$_in\""; }
  ### topmost starting directory
  #
  #
  _cmd+="$_maxdepth"
  ### has to go after starting path (_in) and before other options
  #
  #
  _name="$(optionArg --name "$@")"
  #
  [[ "$_name" =~ []*?] ]]  && { _name="'${_name}'"; }
  ### quote argument if it contains widldcards so 'find' handles sanely
  #
  [[ "$_name" ]]  && { _cmd+=" -name $_name"; }
  # [[ "$_name" ]]  && { _cmd+=" -name \"$_name\""; }
  #
  #
  # ARGS="$*"; inspVar ARGS _in _name _cmd _maxdepth
  #
  eval "$_cmd"
  ### eval required in order to do globbing(wildcards), etc. for 'find' command
  #
  return $?
}

function fileIn () {
  fnInit "$FUNCNAME.20190615" "$@"  && return 0
  #
  local FILE="$1"; shift
  local RESULT=
  local ERR=
  local path=
  #
  # if all supplied paths fail, file in $HOMEDIR
  for path in "$@" "$HOMEDIR"
  do
    if isFound "$path/$FILE"
    then
      if isWritable "$path/$FILE"
      then
        RESULT="$path/$FILE"
        break
      else
        : ### try another
        break
      fi
    else
      if isFound "$path"
      then
        if isWritable "$path"
        then
          RESULT="$path/$FILE"
          break
        fi
      else
        if mkdir "$path" 2>/dev/null
        then
          RESULT="$path/$FILE"
          break
        fi
      fi
    fi
  done
  #
  if [[ $RESULT ]]
  then
    echo "$RESULT"
    return 0
  else
    return 1
  fi
}

function fileListByTimestamp () {
  fnInit "$FUNCNAME.20180208" "$@"  && return 0
  #
  dialog -- "$(printDecoded "$(ls -ltr --time-style=full-iso $1)")"
}

function fileLocal () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  df -l "$1" >/dev/null 2>&1  && { return 0; }
  return 1
}

function fileRevised () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  date '+%m/%d/%Y %H:%M:%S' --reference "$1"
}

function fileOpen () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _file
  local _filedir
  local _filepath
  #
  local _link
  local _linkdir
  local _linkpath
  local _linkrel
  #
  _file="$(optionArg --:1 "$@")"
  # _file="$(argNonOption 1 "$@")"
  ### directory name to create is first positional argument
  ### (--options and their arguments are ignored by argsPos())
  #
  # ARGS="$*"; inspVar ARGS _file
  #
  #
  _filedir="$( pathStr --dir  "$_file")"
  _filepath="$(pathStr --path "$_file")"
  ### get full, absolute path to dir
  #
  if _link="$(optionArg --link "$@")"
  ### arg may be relative or absolute path, including link name
  then
    _linkpath="$(pathStr --path "$_link")"
    _linkrel="$( pathRelativePy $_linkpath $_filepath)"
    # DO NOT MAKE ABSOLUTE
    #   would result in always creating absolute symlinks
  fi
  #
  # inspVar _file _filedir _filepath _link _linkpath _linkrel
  #
  isFileWrite "$_file"  && { printf "${_filepath}\n"; return 0; }
  ### file already exists and is writable so return
  #
  if mkdir --parents "$_filedir"
  ### create directory (and any parents required) using argument as given
  then
    touch "$_filepath"
    #
    [[ "$_linkrel" ]]   && { ln -fs "$_linkrel" "$_linkpath"; }
    ### recreate relative link (forced)
    #
    printf "%s\n" "$_filepath"
    return 0
  else
    abortShow operationfailed "Unable to create file: ${_filepath} ${NL}${NL}( more at ${LOGFILE}... )"
    return 1
  fi
}

function fileQuery () {
  fnInit "$FUNCNAME.20200505" "$@"  && return 0
  #
  ###
  ### NOTE
  ###   Options --from and --into are synonyms.
  ###   They both take the file(s) that will be operated upon.
  ###   '--into' is just more grammatical for --insert.
  ###
  #
  local __=""
  local _a=""
  local _errmsg=""
  local _f=""
  local _file=""
  local _from=""
  local _into=""
  local _like=""
  local _line=""
  local _msgdelete=""
  local _msgfilename=""
  local _msgnotfound=""
  local _path=""
  local _quiet=""
  local _rc=
  local _resultset=""
  local _selarg=""
  local _set=""
  local _text=""
  local _tmpfile=""
  local _where=""
  local _where_not=""
  local _where_regex=""
  local _width=""
  #
  local -a _gopts
  local -a _query
  local -a _resultfiles
  local -a _resultlines
  ### arrays
  #
  _gopts=()
  _query=()
  _resultfiles=()
  _resultlines=()
  ### initialize option arrays
  #
  _errmsg="Source file to update is required"
  _msgdelete="Delete lines containing strings like this in these files?"
  _msgfilename="Select filename"
  _msgnotfound="${NL}${NL}    Not Found"
  _tmpfile="$TMPDIR/fileQuery"
  _width="1000"
  ### initialize variables
  #
  [[ "$1" =~ --select|--insert|--update|--delete ]]  || { $FUNCNAME --help;       return 0; }
  ### required operation must be $1
  #
  _quiet="$(option --quiet "$@")"
  # _quiet="$(optionArg --quiet "$@")"  && { _quiet="--quiet"; }
  ### default path is logical current working directory
  #
  __="$(optionArg --into "$@")"    && { _into="$__"; _from="$__"; }
  ### _into and _from are both the file 'glob' to operate on
  #
  __="$(optionArg --from "$@")"    && { _into="$__"; _from="$__"; }
  ### _into and _from are both the file 'glob' to operate on
  #
  isDirExists "$_from"  && { _from="$_from/$(fileSelect --filename "$_from" --text "$_msgfilename in $_from")"; }
  ### if a directory, present dialog to select a file
  #
  _file="$(pathStr --file "$_from")"
  _path="$(pathStr --dir  "$_from")"
  ### set _file and _path
  #
  [[ "$_file" ]]                    || { $FUNCNAME --help --before "$_errmsg"; return 0; }
  ### _file is required
  #
  [[ "$_path" ]]                    || { _path="$PWD"; }
  ### default to current PWD
  #
  _where="$(      optionArg --where       "$@")"
  _where_not="$(  optionArg --where-not   "$@")"
  _where_regex="$(optionArg --where-regex "$@")"
  _like="$(       optionArg --like        "$@")"
  _set="$(        optionArg --set         "$@")"
  _selarg="$(     optionArg --select      "$@")"; [[ "$_selarg" == "with-filename" ]]  && { _gopts+=("--with-filename"); }
  #
  # _ARGS="$*"; inspVar --func _gopts[@] _query[@] _resultfiles[@] _resultlines[@]
  #
  if [[ ! "$_where$_where_not$_where_regex" ]]
  then
    _query=( grep --fixed-strings --recursive --with-filename "${_gopts[@]}" -- "" "$_from" )
    ### build query command
    #
    _resultset="$( "${_query[@]}" )"; printf "%s" "$_resultset" >"$_tmpfile"
    ### run query command to get files containing fixed string matches
  else
    [[ "$_where"       ]]  && {
      _query=( grep --fixed-strings --recursive --with-filename "${_gopts[@]}" -- "$_where" "$_from" )
      ### build query command
      #
      _resultset="$( "${_query[@]}" )"; printf "%s" "$_resultset" >"$_tmpfile"
      ### run query command to get files containing fixed string matches
    }
    #
    [[ "$_where_not"   ]]  && {
      if [[ "$_resultset" ]]
      then
        _query=( grep --fixed-strings --recursive --label="$_from" --invert-match -- "$_where_not" "$_tmpfile" )
        ### search results of other where* clauses if any instead of $_from
      else
        _query=( grep --fixed-strings --recursive --with-filename  --invert-match -- "$_where_not" "$_from"    )
        ### build query command
      fi
      #
      _resultset="$( "${_query[@]}" )"; printf "%s" "$_resultset" >"$_tmpfile"
      ### run query command to get files NOT containing fixed string matches
    }
    #
    [[ "$_where_regex" ]]  && {
      if [[ "$_resultset" ]]
      then
        _query=( grep --extended-regexp --recursive --label="$_from" -- "$_where_regex" "$_tmpfile" )
        ### search results of other where* clauses if any instead of $_from
      else
        _query=( grep --extended-regexp --recursive --with-filename  -- "$_where_regex" "$_from"    )
        ### build query command
      fi
      #
      _resultset="$( "${_query[@]}" )"; printf "%s" "$_resultset" >"$_tmpfile"
      ### run query command to get files containing extended regular expression matches
    }
  fi
  #
  _resultfiles=( "$(echo "$_resultset" | grep --only-matching --extended-regexp "^.*:" | cut --delimiter=: --fields=1 )" )
  ### make separate array of files
  #
  _resultlines=( "$(echo "$_resultset" | grep --only-matching --extended-regexp ":.*$" | cut -c2- )" )
  ### make separate array of lines
  #
  rm "$_tmpfile"
  ### cleanup
  #
  case "$1" in
    --select)
      if [[ "$_like" ]]
      then
        _results+="$( grep --only-matching --extended-regexp "$_like" <<<"${_resultlines[@]}" )"
      else
        _results="$_resultset"
      fi
      #
      _ARGS="$*"; inspVar --func _gopts[@] _query[@] _resultfiles[@] _resultlines[@]
      # exit
      ### diagnostic
      #
      [[ "$_results" ]]  && { printf "%s" "$_results" | sort; }
      ### print the results text
      #
      ;;
    --insert)
      [[ "$_set"   ]]  || { $FUNCNAME --help; return 0; }
      ### --set is required
      #
      _into="$( echo "$_resultfiles" | head --lines=1 )"
      ### can only insert to 1 file at a time(?)
      #
      isFileExists "$_into"  || {
        [[ ! "$_quiet" ]]  && { gtkQuestion "Create ${_into}?" --title "$TITLE: $FUNCNAME"  || { return 1; }; }
        #
        touch "$_into"
      }
      ### create a new file if necessary
      #
      [[ ! "$_quiet" ]]  && { gtkQuestion "Insert '$_set'${NL}  into...${NL}    $_into" --title "$TITLE: $FUNCNAME"  || { return 1; }; }
      #
      printf "%s$NL" "$_set" >> "$_into"; _rc=$?
      # printf "Inserted '%s' into '%s' ...$NL" "$_set" "$_into"
      ### insert into (append to) file
      #
      ;;
    --update)
      [[ "$_where"                          ]]  || { $FUNCNAME --help; return 0; }
      [[ "$_like"                           ]]  || { $FUNCNAME --help; return 0; }
      [[ "$_set"                            ]]  || { $FUNCNAME --help; return 0; }
      ### --where, --like and --set clauses are required
      #
      [[ "$_resultset"                      ]]  || {                   return 1; }
      ### no files to update
      #
      _text="
Update these files, changing every occurrance of...
    '$_like'
to...
    '$_set'

        Proceed?"
      #
      [[ ! "$_quiet" ]] && {
        dialogConfirm --text "$_text" --info "${_resultfiles[@]}" --title "$TITLE: $FUNCNAME"  || { return 1; }
      }
      #
      for _f in "${_resultfiles[@]}"
      do
        sed  --in-place -e "s|$_like|$_set|"  "$_f"; _rc=$?
      done
      ### update files containing _where by changing _like to _set
      ;;
    --delete)
      [[ "$_where$_where_not$_where_regex" ]]  || { $FUNCNAME --help; return 0; }
      ### a --where* clause is required
      #
      [[ "$_resultset"                     ]]  || {                   return 1; }
      ### no files to delete lines in
      #
      _from="$(echo "$_resultfiles" | head --lines=1)"
      ### only delete from one file at a time
      #
      _line="$(echo "$_resultlines" | head --lines=1)"
      ### only delete one line at a time
      #
      _msg="
Delete...
      $_line

  From...
      $_from

  Proceed"
      #
      [[ ! "$_quiet" ]] && {
        if gtkQuestion "$_msg" --width "$_width"
        then
          grep --fixed-strings --invert-match "$_line" "$_from" >"$_tmpfile"
          ### copy all lines except deleted lines to $_tmpfile
          #
          chown --reference="$_from" "$_tmpfile"
          ### reset owner:group of $_tmpfile to match $_from
          #
          chmod --reference="$_from" "$_tmpfile"
          ### reset permissions of $_tmpfile to match $_from
          #
          archive "$_from"
          ### make a backup of old $_from
          #
          cp -a "$_tmpfile" "$_from"
          ### replace $_from with $_tmpfile
          #
          rm "$_tmpfile"
          ### cleanup
        fi
      }
      ;;
    *)
      $FUNCNAME --help
      return 0
      ;;
  esac
  #
  return $_rc
}

function fileSelectShow () { aliasOf fileSelect "$@"; }

function fileSelect () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local __=""
  local _dir=""
  local _file=""
  local _files=""
  local _f=""
  local _geometry=""
  local _guidialogtext=""
  local _msg=""
  local _separator="|"
  local _title=""
  #
  _geometry="${_geometry:-660x600}"
  _guidialogtext="Right-click in right-hand pane for sizes, hidden files or to add bookmarks$NL"
  _title="$TITLE:  Select File"
  #
  [[ "$1" =~ ^-- ]]  || _dir="$1"
  [[ "$_dir"     ]]  || _dir="$(optionArg --dir "$@")"
  ### if first arg is not an option, assume it to be the starting directory
  #
  ###
  ### 20171222  LEFTOFF - set _dir to '.'? Help on null?
  ###
  #
  __="$(optionArg --title     "$@")"  && { _title="$__"                ; }
  #
  __="$(optionArg --geometry  "$@")"  && { _geometry="$__"             ; }
  #
  __="$(optionArg --separator "$@")"  && { _separator="$__"            ; }
  #
  _file="$(optionArg --file   "$@")"
  #
  isDirExists "$_dir"                 || { _dir="$(cd "$_dir"; pwd -L)"; }
  ### default to current directory
  #
  isFileLink  "$_dir"  && { _guidialogtext="$_dir is a link to $(linkTarget "$_dir")$NL$NL    $_guidialogtext"; }
  ### default to current directory
  #
  # ARGS="$*"; inspVar ARGS _title _guidialogtext _geometry _dir _file _separator _msg
  #
  # cd "$_dir"
  # _dir="$(pwd)"
  #
  case $UI in
    CLI)
      printf "%s ---- " "$_dir"
      ls -l
      printf "\nEnter file name(s) to select separated by a space: "
      _files="$(inputCli)"
      if [[ "$_files" ]]
      then
        for _f in $_files
        do
          printf "%s\n" "$_dir/$_f"
          ### print file name
        done
        return 0
      else
        return 1
      fi
      ;;
    GUI)
      case "$DLG" in
        yad*)
          _file="$(
            cd "$_dir";
            yad --file-selection        \
              --title="$_title"         \
              --geometry="$_geometry"   \
              --text="$_guidialogtext"  \
              --display=":0"            \
              --multiple                \
              --confirm-overwrite       \
              --filename="$_file"       \
              --separator="$_separator" \
          )"
          #    --add-preview             \
          #    --quoted-output           \
          ### not support by yad on LX01
          ;;
        zenity*)
          _geometry="${_geometry#-}"
          ### strip off leading hyphen for zenity
          #
          _file="$(
            cd "$_dir";
            zenity  --file-selection          \
                    --title="$_title"         \
                    --height="${_geometry#*x}"\
                    --width="${_geometry%x*}" \
                    --text="$_guidialogtext"  \
                    --display=":0"            \
                    --multiple                \
                    --confirm-overwrite       \
                    --filename="$_file"       \
                    --separator="$_separator" \
          )"
          ;;
        *)
          abortDLG
          # abortShow filenotfound "Unable to locate either zenity or yad dialogers"
          ;;
      esac
      ;;
    LOG)
      _msg="Directory:  $_dir"
      log --status "$_msg"
      ;;
    *)
      abortUI
  esac
  #
  [[ "$_file" ]]  && { printf "%s\n" "$_file"; return 0; }
  #
  return 1
}

function fileShow () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _file="$1"
  #
  # inspVar _file
  #
  [[ "$_file" == "-"   ]]  && { _file="$_stdin"; }
  ### if no arguments, use stdin
  #
  [[ "$_file"          ]]  || { _file="$(fileSelectShow ".")"; }
  ### if no file given, ask for it
  #
  # inspVar _file
  #
  isFileExists "$_file"    && { dialog --middle --title="$(pathStr --file "$_file")" -- "$(cat $_file)"; return 0; }
  #
  return 1
}

function fileUpdate () {
  fnInit "$FUNCNAME.20190606" "$@"  && return 0
  #
  [[ "$1" ]]  || { "$FUNCNAME" --help; return 0; }
  ### if no arguments, show --help
  #
  local _cachepath="$HOMEDIR/cache"
  local _colname="Target Directory"
  local _d=""
  local _datetime="$(date +%Y%m%d-%H%M%S)"
  local _delimiter="|"                    ### YAD field delimiter
  local _dir=""
  local _dstd=""
  local _dstd_indent=""
  local _f=""
  local _file=""
  local _host="$(hostname)"
  local _label="Full path"
  local _msg_archive=""
  local _msg_copy=""
  local _msg_source=""
  local _msg_targetdir="Update same file in selected target directory..."
  local _result=""
  local _source=""
  local _srcd=""
  local _srcd_indent=""
  local _targetdir=""                     ### target directory
  local _targetdirs=""                    ### target directories known
  local _targetdirs_ca=""                 ### target directories known - cached
  local _title="$TITLE.$FUNCNAME() - Update file from changed development copy"
  local _tmppath="$HOMEDIR/tmp"
  # local _dtext_targeth="Update copy of file in same directory on host..."
  # local -a _targetdirs_ar                     ### target directories array for yad/zenity
  # local _targethosts=""                       ### target hosts
  # local _targethosts_ca=""                    ### target hosts - cached
  # local -a _targethosts_ar                    ### target hosts array for yad/zenity
  ### 20170424 ABANDONED multiple-targets development for now
  ###   GTK+ bugs making --multiple option unreliable?
  #
  #
  [[ "$1" =~ ^-- ]]  || _source="$1"
  [[ "$_source"  ]]  || _source="$(optionArg --source "$@")"
  # _source="$(dialogEntry --text "$_dtext_source" --label="$_label" -- "$_source")"     || return 1
  ### get _source
  ###   if first arg is not an option, assume it is the _source file
  ###   if first arg IS an option, use if it is --source
  ###   prompt to modify or confirm (DISABLED 20170710)
  #
  _source="$(pathStr --path $_source)"
  ### resolve partial path names
  #
  _targetdir="$(optionArg --targetdir "$@")"
  _targetdirs_ca="$(fileQuery --select --from "$_cachepath/$FUNCNAME" --where "TARGETDIR=")"
  # _targetdirs_ca="$(fileQuery --select --path "$_cachepath" --file "$FUNCNAME" --where "TARGETDIR=")"
  _targetdirs_ca="$(sed "/^$/d;s/^.*TARGETDIR=\"\(.*\)\"/\1/" <<< "$_targetdirs_ca")"
  _targetdirs+="$_targetdirs_ca"
  # _targetdirs+="$NL$_targetdirs_ca"
  ### get target directories
  ###   from commandline
  ###   from cache
  ###   delete blank lines and extract just the pathname from the cache entries
  ###   append cached target dirs to any target dirs from commandline
  #
  _targetdirs="$(sort --unique --ignore-leading-blanks  <<< "$_targetdirs")"
  # _targetdirs_ar=( $(sort --unique --ignore-leading-blanks  <<< "$_targetdirs_ca") )
  # _targetdirs_ar=( $(sort --unique <<< "$_targetdirs_ca") )
  # readarray -t _targetdirs_ar < <(sort --unique <<< "$_targetdirs_ca")
  ### eliminate dups
  #
  _msg_source="\
Source file...
    $_source
"
  #
  _targetdir="$(dialogSelect --title="$_title" --text "$_msg_source${NL}$_msg_targetdir${NL}" --column "$_colname..." -- "$_targetdir" "$_targetdirs")"  || { return 1; }
  # _targetdir="$(dialogSelect --title="$_title" --text "$_dtext_targetd${NL}    $_source${NL}In the directory...${NL}${NL}" --column "$_colname..." -- "$_targetdir" "$_targetdirs")"  || { return 1; }
  # _targetdir="$(dialogSelect --text "$_dtext_targetd$NL    $_source" --column "$_colname..." -- "$_targetdirs")"  || { return 1; }
  # _targetdir="$(dialogSelect --text "$_dtext_targetd$NL $_source" -- "${_targetdirs_ar[@]}")"  || return 1
  ### present all for selection at runtime
  ### return with fail if none selected
  #
  _targetdir="${_targetdir%$_delimiter}"
  ### since this version does accept multiple targets, strip off YAD's field delimiter
  #
  [[ "$_targetdir" ]]  && {
    _targetdirs_ca+="$NL$_targetdir$NL"
    # _targetdirs_ar+=("$_targetdirs")
    ### append selected dir to cache list (may result in dups)
    #
    fileQuery --delete --quiet --from "$_cachepath/$FUNCNAME" --where "TARGETDIR=" --like  "TARGETDIR=.*"
    # fileQuery --delete --path "$_cachepath" --file "$FUNCNAME" --where "TARGETDIR=" --like  "TARGETDIR=.*"
    ### delete "TARGETDIR=..." lines from cache file
    #
    sed "/^$/d;s/..*/TARGETDIR=\"&\"/"  < <(printf "%s\n" "$_targetdirs_ca"  | sort --unique)  >>"$_cachepath/$FUNCNAME"
    ### rewrite valid 'TARGETDIR=...' lines to cache file, eliminating dups and deleting blanks
  }
  ### update cache with any new/changed target dirs
  #
  #
  ### [OBSOLETE]
  ###   POSSIBLY RETHINK CROSS-HOST SUPPORT
  ###     Without this, changes to a file on LX01 (for example) requires...
  ###       Edit on master development copy (LX03:/home/DocSalvager/...)
  ###       kit fileUpdate --source FILEPATH --targetdirs /home/DocSalvager/LX01-mirror-on-LX03
  ###       On LX01, do...
  ###         syncPull its directory on LX03/home/DocSalvager/...
  ###         kit fileUpdate --source /home/DocSalvager/LX01-copy-just-syncPulled --targetdirs system-location
  ###
  # _targethosts="$(optionArg targethosts "$@")"; [[ "$_targethosts" ]]  || _targethosts="$_host"
  # _targethosts_ca="$(config --select --path "$_cachepath" --file "$FUNCNAME" --where "TARGETHOST=")"
  # _targethosts_ca="$(sed "/^$/d;s/^.*:TARGETHOST=\"\(.*\)\"/\1/" <<< "$_targethosts_ca")"
  # readarray -t _targethosts_ar < <(printf "%s\n" "$_targethosts" "$_targethosts_ca"  | sort --unique)
  # _targethosts="$(dialogSelect            --text "$_dtext_targeth$NL    $_source" -- "${_targethosts_ar[@]}")"  || return 1
  # [[ "$_targethosts" ]]  && {
  #   _targethosts_ar+=("$_targethosts")
  #   config --delete --path "$_cachepath" --file "$FUNCNAME" --where "TARGETHOST=" --like  "TARGETHOST=.*"
  #   sed "/^$/d;s/..*/TARGETHOST=\"&\"/"  < <(printf "%s\n" "${_targethosts_ar[@]}"  | sort --unique)  >>"$_cachepath/$FUNCNAME"
  # }
  ### get target hosts (CURRENTLY ONLY ONE HOST AT A TIME SUPPORTED)
  ###   from commandline
  ###   from cache and extract just the pathname
  ###   put a copy in an array for yad and zenity
  ###   present all for selection at runtime
  ###   replace cache with any new list
  #
  #
  _file="${_source##*/}"
  _srcd="${_source%/*}"
  _dstd="${_targetdir}"
  #
  _srcd_indent="$(sed "s/.*/    &/"   <<< "$_srcd")"
  _dstd_indent="$(sed "s/.*/    &/"   <<< "$_dstd")"
  ### append filename and indent with spaces for prompts
  #
  _msg_archive="
Archive...
$_dstd_indent/$_file
And update it with...
$_srcd_indent/$_file
"
  _msg_copy="
Copy...
$_srcd_indent/$_file
To...
$_dstd_indent/$_file
"
  #
  dialogConfirm --text "Proceed?" --info "$_msg_archive" --title "$_title"  && {
    for _d in $_dstd;  do archive "$_d/$_file"; done
    # for _d in $_dstd;  do archive "$_d/$_file" --archivesdir="$_d/$ARCHIVESDIRNAME"; done
    #
    dialogConfirm --text "Proceed?" --info "$_msg_copy" --title "$_title"  && {
      for _d in $_dstd; do  cp -a "$_srcd/$_file" "$_d";  done
    }
  }
  #
  # _ARGS="$*"; inspVar --func
  # exit
  ### diagnostic
  #
  return $?
}

function files () { aliasOf fileList "$@"; }

function fileList () {
  fnInit "$FUNCNAME.20190709" "$@"  && return 0
  #
  local __=""
  local _arg1=""
  local _files=""
  local _grep=""
  local _lsargs=""
  local _opt=""
  #
  # _grep="-e '*'"
  ### initialize
  #
  if [[ "$1" =~ ^--(file|dir|pipe|sock|all) ]]
  then
    _opt="$1"
    _arg1="2"
  else
    _opt="--all"
    _arg1="1"
  fi
  #
  case "$_opt" in
    --file)
      _grep="-v [=/|>]$"
      ###
      ### on PuppyLinux 528...
      ###   single-quotes around the square-bracket phrase treats it as a
      ###   literal string but works on commandline because the quotes are
      ###   automatically stripped off
      #
      # compgen -A file "${@:$_arg1}"  && return 0
      # # compgen -G "${@:$_arg1}" | ls --escape  && return 0
      # # compgen -G ${@:$_arg1} | ls --escape  && return 0
      # # compgen -G "${@:$_arg1}" | ls --escape  && return 0
      # # compgen -A file "${@:$_arg1}"  && return 0
      # ### fast, but only works for a known prefix
      # #
      # return 1
      ;; ### regular files
    --dir)
      _grep="/$"
      ;; ### directories
    --pipe)
      _grep="|$"
      ;; ### pipes
    --sock)
      _grep="=$"
      ;; ### sockets
    --all)
      _grep="''"
      # _grep="-v ''"
      ;; ### default to --all if no --option given
  esac
  #
  ### fileList --ls "${@:$_arg1}" --grep $_grep
  ### --ls args
  ###   MUST be quoted
  ### --grep args
  ###   must NOT be quoted
  #
  # set -x
  # __="$(optionArg --grep "$@")" && { _grep="${__:+-e $__}"; }
  # __="$(optionArg --grep "$@")" && { _grep="${__:+-e $__ ; grep $_grep}"; }
  # set +x
  ### experimental adhoc grep
  #
  # _ARGS="$*"; inspVar --func
  #
  [[ "$@:$_arg1" ]]  || { ls --almost-all --escape --classify -1dL * | grep $_grep  | sed 's/[@*=|>/]$//'; return $?; }
  ### no directory name supplied
  #
  _files="$(ls --almost-all --escape --classify -1dL "${@:$_arg1}" 2>/dev/null)"  && {
    echo "$_files" | grep $_grep  | sed 's/[@*=|>/]$//'                                                   ; return 0; }
  # ls --almost-all --escape --classify -1dL "${@:$_arg1}" | grep $_grep  | sed 's/[@*=|>/]$//'
  # ls --almost-all --escape --classify -1dL * | grep $_grep
  # ls --almost-all --escape --classify -1dL * | grep $_grep  | sed 's/[@*=|>/]$//'
  # ls --escape --classify -1L $_lsoptions | grep $_grep  | sed 's/[@*=|>/]$//'
  # ls --escape --classify -1L "${@:$_arg1}" | grep $_grep  | sed 's/[@*=|>/]$//'
  # ls --escape --classify -1dL "${@:$_arg1}" | grep "$_grep"  | sed 's/[@*=|>/]$//'
  ### list contents of directories/files specified by nonoption arguments
  #
  errorShow filenotfound "${@:$_arg1}"
  #
  return 1
}

# function filesList () { aliasOf fileList "$@"; }
#
# function fileList () {
#   fnInit ${FUNCNAME} "$@"  && return 0
#   #
#   local -a _grep_args
#   local -a _ls_args
#   #
#   # _ARGS="$*"; inspVar --func
#   #
#   _ls_args=( "$(optionArg --ls "$@")" ); [[ "$_ls_args" ]]  || { _ls_args[0]="*"; }
#   # _ls_args=( "$(optionArg --ls "$@")" ); [[ "$_ls_args" ]]  || { _ls_args="*"; }
#   ### ls arguments
#   #
#   _grep_args=( "$(optionArg --grep "$@")" )
#   ### grep options
#   #
#   # _ARGS="$*"; inspVar --func
#   #
#   if [[ "$_grep_args" ]]
#   then
#     ls --escape --classify -1dL ${_ls_args[*]} | grep ${_grep_args[@]}  | sed 's/[@*=|>/]$//'
#     # ls --escape --classify -1dL ${_ls_args[*]}/* | grep ${_grep_args[@]}  | sed 's/[@*=|>/]$//'
#     # ls --escape --classify -1dL ${_ls_args[*]}/* | grep ${_grep_args[@]}  | sed 's/[@*=|>/]$//'
#   else
#     ls --escape --classify -1dL ${_ls_args[@]} |                     sed 's/[@*=|>/]$//'
#     # ls --escape --classify -1dL ${_ls_args[@]}/* |                     sed 's/[@*=|>/]$//'
#   fi
#   #
#   return 0
# }

function fnInit () {
  ### Return Codes
  ###   0   True. All done. Do NOT continue processing.
  ###   1   False. Nothing done. Continue processing.
  ###
  #
  # _ARGS="$*"; echo "${FUNCNAME[2]} --> ${FUNCNAME[1]}:  $(echo ${_ARGS:0:80})" >&2
  ### diagnostics (uncomment for a good function trace)
  #
  [[ "$CMD"                              ]]  || { return 1; }
  ### cannot process fnInit till CMD() is set by ___init()
  #
  ### Supported Argument Conditions...
  ### ('--help|*' means one of --help|--version|--help-all|--note-all)
  ###   <none>
  ###   --help|*
  ###   --help|* [...]
  ###   fnInit
  ###   fnInit --help|* [...]
  ###   fnInit --revised <00000000> --help|* [...]
  ###   <functionName>
  ###   <functionName> [...]
  ###   <functionName> --help|*
  ###   <functionName> --help|* [...]
  ###   <functionName> --revised <00000000> --help|* [...]
  ###
  local __=""                             ### temporary variable
  local _argsline=""                      ### beginning of commandline for output by inspFn()
  local _fns=""                           ### space-string of the function names on the stack excluding this one
  local _fn=""                            ### name of calling function
  local _revised=""                       ### last revision date of function being initialized
  local _revised_fninit="20190726"        ### last revision date of this function (fnInit())
  #
  _fns="${FUNCNAME[*]:1}"; [[ "$_fns" =~ ${FUNCNAME[0]} ]]  && { return 1; }
  ### Prevent Circular Reference
  ###   Do not execute this function (fnInit) if it is already being executed (is on the call stack).
  ###   THIS ELIMINATES FUNCTION RECURSION?
  ###
  ### Technique (for future reference)
  ###   How it works ( [[ "$_fns" =~ ${FUNCNAME[0]} ]] )
  ###     Simplified (and hopefully faster) just uses '=~' to search _fns
  ###       $_fns is same space-delimited list of the names of the functions on
  ###       the stack. It excludes this one by starting at the second element
  ###       (element 1) of the FUNCNAME array.
  ###   How it works ( [[ "${_fns/${FUNCNAME[0]}/}" != "$_fns" ]] )
  ###     The test uses same technique as isIn()...
  ###       $_fns is a space-delimited list of the functions on the stack except this one.
  ###       First operand removes this function name from the list if found in it
  ###       so the result will be different from the complete list.
  ###   Why we need $_fns:
  ###     Seems like this should work but it does not...
  ###       if [[ "${FUNCNAME[*]:1/$FUNCNAME/}" != "${FUNCNAME[*]:1}" ]]; then ...
  ###     It appears to fail silently and exit the script so neither 'then' nor
  ###     'else' branch executes. Storing the array into a temporary string
  ###     variable works but why is it necessary?
  ###     20150228  Submitted Question http://unix.stackexchange.com/q/186942/27437
  ###       - In general, you can't use multiple variable expansion modifiers
  ###         in the same expression. –  Barmar
  ###   Resource:
  ###       http://www.electricmonk.nl/log/2008/08/07/dependency-resolving-algorithm/
  #
  [[ "$1" =~ [.].* ]]  && { _revised="${1#*.}"; }
  ### revision date now appended to first argument
  ### which contains parent FUNCNAME as in FUNCNAME.YYYYMMDD
  ###   replaces --revised ...
  #
  _fn="$CMD"
  ### if no arguments or first argument is an --option, then _fn=CMD
  #
  [[ "$_fn" == "$FUNCNAME" ]]  && { _revised="$_revised_fninit"; }
  ### reset revision date if getting --help, --version, etc. for fnInit
  #
  _argsline="$(builtin echo $*)"
  # _argsline="${FUNCNAME[2]}...$(builtin echo $*)"
  # _argsline="$(builtin echo $CMD $*)"
  # for __ in "$@"; do _argsline+="$__ "; done
  ### quote command and each argument for processing by inspFn() and ssh command below
  ### collapse possible multiline arguments into one and double-quote each
  ### - is required for inspFn() call and ssh command (HOSTremote... code) below
  ### - (MUST use echo, not printf)
  #
  ### diagnostics
  # echo "$_argsline"                            >&2
  # echo "${FUNCNAME[2]} --> ${FUNCNAME[1]} -->" >&2
  # printAt 40 "fnInit (\$CMD[@]): ${CMD[@]}"    >&2
  # printAt 40 "fnInit (     \$@): $@"           >&2
  ### diagnostics
  #
  [[ "$INSPECT" ]]  && { inspFn "$CMD" "${FUNCNAME[2]}" "${FUNCNAME[1]}" "$_argsline" >>"$INSPFILE"; TIMELAST="$(timeMs)"; }
  ### <function> ... --inspect (function calls)
  #
  [[ "$INSPECT" > "1" ]]  && { inspFnLineage "$@"; }
  ### print complete function lineage and arguments
  #
  HOSTremote="$(optionArg --host "$@")"  && {
    [[ "$HOST" != "$HOSTremote" ]]  && {
      ssh -t "$HOSTremote" 'bash -l -s' <<< "DISPLAY=:0 kit --alt $_argsline"
      #
      # (( $? ))  && HOSTremote="FAILED"
      #
      return 0
    }
    # if [[ "$HOST" != "$HOSTremote" ]]
    # then
    #   ssh -t "$HOSTremote" 'bash -l -s' <<< "DISPLAY=:0 kit --alt $_argsline"; _error=$?
    #   # echo "DISPLAY=:0 /root/bin/kit-043 --alt $_argsline; exit" | ssh -v -t -o ConnectTimeout "$HOSTremote"
    #   # ssh -t -v "$HOSTremote" -t DISPLAY=:0 gnome-terminal --profile=execute --command \"/root/bin/kit-043 --alt \""$_argsline"
    #   # ssh -v "$HOSTremote" -t DISPLAY=:0 gnome-terminal --profile=execute
    #   # ssh -v "$HOSTremote" -t DISPLAY=:0 xterm -e nohup bash -l -c kit-043 "\"--alt\" \"$_argsline\""
    #   # ssh -v "$HOSTremote" -t DISPLAY=:0 nohup xterm -ls -hold -e nohup bash -l -c kit-043 --alt "$_argsline"
    #   # ssh -v "$HOSTremote" -t DISPLAY=:0 nohup bash -l -c "kit-043 --alt $_argsline; echo $?"
    #   # ssh "$HOSTremote" -t DISPLAY=:0 roxterm --execute nohup kit-043 --alt $_argsline  ### WORKS
    #   # ssh "$HOSTremote" -t DISPLAY=:0 roxterm --execute nohup kit-043 --alt $CMD "${CMD[@]}"
    #   # ssh "$HOSTremote" -t DISPLAY=:0 roxterm --execute nohup meta gtkQuestion  ### WORKS
    #   # ssh "$HOSTremote" -t DISPLAY=:0 nohup bash -l -c "meta" gtkQuestion
    #   # ssh "$HOSTremote" -t DISPLAY=:0 nohup bash -l -c /root/bin/kit-043 --alt $CMD "${CMD[@]}"
    #   # ssh "$HOSTremote" DISPLAY=:0 /root/bin/kit-043 --alt $CMD "${CMD[@]}"; return 0
    # else
    #   HOSTremote="$HOSTremote"
    # fi
    #
    # echo "$HOST: '$_error'" >&2
  }
  ### Execute on remote host?
  #
  [[ "${FUNCNAME[1]}" =~ ${CMD}|main|source ]]  || {                                        return 1; }
  # [[ "${FUNCNAME[1]}" =~ ${CMD}|main|source ]]  || {                                    return 1; } ### NO dialog HANG IF return 0!!!
  # [[ "${FUNCNAME[1]}" =~ ${CMD}|main|source|kit ]]  || {                                    return 1; } ### NO dialog HANG IF return 0!!!
  ### ONLY EXECUTE FOR THE PRIMARY CMD FUNCTION
  ###   prevents further execution during any other function such as initalization and exit
  #
  isOption --help     "$@"   && { noteShow "$_fn" --title="$TITLE:  $_fn ($_revised)" "$@"; return 0; }
  ### fnInit "${FUNCNAME}" --help
  ###   WARNING:  Do NOT pass "$@" to noteShow() as this would cause an endless loop!
  #
  isOption --version  "$@"   && { versionShow "$CMD"                                      ; return 0; }
  ### show function version
  #
  isOption --revised  "$@"   && { echo "$_revised"                                        ; return 0; }
  ### print last revision date as YYYYMMDD
  #
  return 1
  ### fnInit "${FUNCNAME}" --<otheroption> ...
}

function fnList ()  {
  fnInit "$FUNCNAME.20190512" "$@"  && return 0
  #
  local _pfx="$(optionArg --pfx "$@")"
  #
  dialog -- "$(functions "$_pfx")"
  #
  return $?
}

function fnShow ()  {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _fn="$1"
  local _code=""
  local _title=""
  #
  if isFnLoaded "$_fn"
  then
    _code="$(declare -f "$_fn")"
    # _code="$(declare -f "$_fn" | sed -re 's/([\"$])/\\\1/g')"
    # _code="$(declare -f "$_fn")"
    #
    _title="...${_fn}()"
    #
    dialog --middle --title="$_title" -- "$_code"
    #
    return 0
  else
    return 1
  fi
}

function fsMount ()  {
  fnInit "$FUNCNAME.20190606" "$@"  && return 0
  #
  local _awkHost=""
  local _awkStatus=""
  local _cmd=""
  local _dtext=""
  local _file=""
  local _fs=""
  local _fstab=""
  local _mhost=""
  local _mountables=""
  local _mountedsshfs=""
  local _mpoint=""
  local _msg=""
  local _mtab=""
  local _path=""
  local _selection=""
  ### declarations
  #
  _file="fstab"
  _fstab="/etc/fstab"
  _mtab="/etc/mtab"
  _path="/etc"
  ### initializations
  #
  _dtext="If filesystem is Mounted, this will unmount it.${NL}If filesystem is Unmounted, this will mount it."
  # _dtext="Select one (or more with Ctrl-click/Shft-click)"
  #
  _awkHost='{
    split($3, a, " ");
    n=split(a[2], b, "/");
    printf("%s  %s  %s\n",b[n],$2,a[2])
  }'
  _awkStatus='                                \
        ! M { print($1,$2,$3,"FALSE"); next}  \
    $3  ~ M { print($1,$2,$3,"TRUE" ); next}  \
    $3 !~ M { print($1,$2,$3,"FALSE"); next}  \
  '
  #
  _mountables="$(fileQuery --select 'BEGIN{FS=":"} {print $2":"$3}' --from "$_fstab" --like "^sshfs#")"
  # _mountables="$(fileQuery --select 'BEGIN{FS=":"} {print $2 ":" $3}' --from "$_fstab" --like "^sshfs#")"
  # _mountables="$(fileQuery --select value --from "$_fstab" --like "^\s*sshfs")"
  # _mountables="$(fileQuery --select --from "$_path/$_file" --like "^\s*sshfs")"
  # _mountables="$(fileQuery --select --path "$_path" --file "$_file" --like "^\s*sshfs")"
  # _mountables="$(fileQuery --select --path "$_path" --file "_file" --like "^\s*sshfs.*")"
  # _mountables="$(fileQuery --select --path "$_path" --file "fstab" --like "^\s*sshfs.*" | awk -F':' "$_awkHost" | sort --ignore-leading-blanks)"
  # _mountables="$(fileQuery --select --path "$_path" --file "fstab" --like "^\s*sshfs.*" | awk -F':' "$_awkHost" | sort)"
  ### sshfs mountable entries is /etc/fstab
  #
  _mountables="${_mountables:-|}"
  ### if no mountables, set to '|' since leaving null will result in _mountedsshfs
  ### including all mounted filesystems and not just the sshfs ones we want
  #
  _mountedsshfs="$(grep -F "$(awk '{print $1}' <<< "$_mountables")$NL" "$_mtab" | awk '{print $2}' | tr '\n' '|')"
  # _mountedsshfs="$(grep -F "$(awk '{print $1}' <<< "$_mountables")$NL" "$_path/mtab" | awk '{print $2}' | tr '\n' '|')"
  _mountedsshfs="${_mountedsshfs%|}"
  # _mountedsshfs="$(grep -F "$(awk '{print $1}' <<< "$_mountables")" "$_path/mtab" | awk '{print $2}')"
  # _mountedsshfs="$(grep -F "$(awk '{print $1}' <<< "$_mountables")" "$_path/mtab" | awk '{print $2}' | tr '\n' '|')"
  ### mountpoints of mounted filesystems per /etc/mtab
  ###   translate to a '\'-separated list for regex in _awkstatus
  ###   strip off any '\' suffix
  ### grep -F expects newline separated strings
  ### so tack on \n in case there are no mountables at all
  #
  _mountables="$(sed --regexp-extended         's/..*/& FALSE/' <<< "$_mountables")"
  # _mountables="$(sed --regexp-extended         's/\S*/& FALSE/' <<< "$_mountables")"
  # _mountables="$(sed                           's/$/& FALSE/' <<< "$_mountables")"
  #
  _mountables="$(awk -v M="${_mountedsshfs}" "$_awkStatus"      <<< "$_mountables")"
  # _mountables="$(awk -v M="${_mountedsshfs%|}" "$_awkStatus"  <<< "$_mountables")"
  ### set statuses
  #
  _selection="$(dialogSelect --text="$_dtext" --column "Host" "Mountpoint" "fsType" "Mounted?" -- $_mountables)"  || { return 1; }
  # _selection="$(dialogSelect --text="$_dtext" --column "Host" "Filesystem" "Mountpoint" "Mounted?" -- $_mountables)"  || { return 1; }
  # _selection="$(dialogSelect --text="$_dtext" --column "Host" "Filesystem" "Mountpoint" "Mounted?" -- "$_mountables")"  || { return 1; }
  # _selection="$(dialogSelect --text="$_dtext" --column "Host" "Filesystem" "Mountpoint" "Mounted?" -- " " " " " " " " "$_mountables")"  || { return 1; }
  ### selected entry
  #
  # _ARGS="$*"; inspVar --func
  exit
  ### diagnostic
  #
  _selection="${_selection#$_path/$_file:}"
  ### strip off leading filename
  #
  _fs="$( cut --delimiter '|' --fields 1    <<< "$_selection" )"
  # _fs="$(    cut --delimiter '|' --field 2 <<< "$_selection")"; [[ "$_fs" =~ ^sshfs\# ]]  && { _fs="sshfs"; }  || { _fs=""; }
  ### extract filesystem part (field 1)
  #
  _mhost="${_fs#sshfs\#}"
  # _mhost="$( cut --delimiter '|' --field 1 <<< "$_selection")"
  ### extract host name and directory (usually '/') from fs
  #
  _mpoint="$( cut --delimiter '|' --field 2 <<< "$_selection" )"
  # _mpoint="$(awk -F=| '{print $2}' <<< "$_selection")"
  # _mpoint="$(cut --delimiter '|' --field 3 <<< "$_selection")"
  ### extract mountpoint
  #
  _status="$( cut --delimiter '|' --field 4 <<< "$_selection" )"
  ### extract status
  #
  _cmd="mount $_mpoint"; _msg="Mount '${_mhost}' on ${_mpoint}?"
  ### default to 'mount'
  #
  [[ "$_status" == "TRUE" ]]  && { _cmd="umount $_mpoint"; _msg="Unmount '${_mhost}' from $_mpoint?"; }
  ### a toggle: mount when is not mounted and unmount when is mounted
  #
  gtkQuestion "$_msg"         || {                                                          return 1; }
  #
  [[ "$_cmd" =~ ^mount  &&  ( "$_fs" =~ ^sshfs\# )  ]]  && { sshfs "$_mhost"  "$_mpoint"  ; return $?; }
  # [[ "$_cmd" =~ ^mount  &&  ( "$_fs" =~ ^sshfs\# )  ]]  && { sshfs "$_mhost:/"    "$_mpoint"  ; return $?; }
  # [[ "$_cmd" =~ ^mount  &&  ( "$_fs" =~ ^sshfs\# )  ]]  && { inspVar _fs; sshfs "$_mhost:/"    "$_mpoint"  ; return $?; }
  # [[ "$_cmd" =~ ^mount  &&  ( "$_fs" =~ ^sshfs\# )  ]]  && { sshfs "$_fs"    "$_mpoint"  ; return $?; }
  # [[ "$_fs" && ( "$_cmd" =~ ^mount )                ]]  && { sshfs "$_mhost:/" "$_mpoint"   ; return $?; }
  #
  [[ "$_cmd" =~ ^mount                              ]]  && { mount "$_fs"    "$_mpoint"   ; return $?; }
  #
  umount "$_mpoint"
  #
  return $?
}

function functions () { aliasOf names "$@" --type function; }
### "$@" must be first options so that the '--help' inserted by meta is first


function gnomeTerminal () {
  fnInit "$FUNCNAME.20190413" "$@"  && return 0
  #
  LC_ALL="en_US.UTF-8"  gnome-terminal "$@"
  #
  return $?
}

function grepFor () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  ### grep -Ev '#' ssh_config | grep '.' >ssh_config_set_LX03
  #
  local __=""
  local _file=""
  local _sort=""
  local -a _adhoc
  #
  [[ "$1" =~ ^-- ]]  || { _adhoc=( "$@:2" ); }
  [[ "$1"        ]]  || { "$FUNCNAME" --help; return 0  ; }
  ### options
  ###   - if first arg is not an option, assume this is adhoc
  #
  _sort="$(isOption --sort "$@" && echo "SORT")"
  #
  # inspVar --func
  #
  _file="$(optionArg --nocomments "$@")"  &&  {
    [[ "$_file" ]]  || { errorShow filenotfound "File '$_file' not found"; return 1; }
    #
    [[ "$_sort" ]]  && { grep -Ev '#' $_file | grep '.' | sort; return $?; }
    #
    grep -Ev '#' $_file | grep '.'
    return $?
  }
  #
  return 1
}

function gtkActionsGen () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  if [[ $DEBUG ]]
  then
    local s=""
    local WIDGET="$1"
    local SIGNALS='
      activate
      button-press-event
      button-release-event
      changed
      clicked
      configure-event
      cursor-changed
      delete-event
      destroy-event
      file-changed
      focus-in-event
      focus-out-event
      hide
      key-press-event
      key-release-event
      map
      map-event
      primary-icon-press
      primary-icon-release
      realize
      row-activated
      secondary-icon-press
      secondary-icon-release
      show
      toggled
      unmap-event
    '
    #
    # ignored to avoid exceeding max data size of bash
    # which, when exceeded results in no event debug output
    #   enter-notify-event
    #   leave-notify-event
    #
    echo
    for s in $SIGNALS
    do
      echo '<action signal="'$s'">printf "Event:  %20s      received by      %s\n" "'$s'" "'$WIDGET'"</action>'
    done
    printf " \n"
  fi
}

function gtkError () {
  fnInit "$FUNCNAME.20200428" "$@"  && return 0
  #
  yad --title="E R R O R" --image="dialog-error" --borders=20 --image-on-top --text="${NL}$(printEncoded "$*")${NL}"   & ### background
  #
  return
}

function gtkExec () {
  fnInit "$FUNCNAME.20200503" "$@"  && return 0
  #
  local __=""
  local _a=""
  local _cache=""
  local _command=""
  local _commandline=""
  local _height=""
  local _match_files=""
  local _match_lines=""
  local _msg=""
  local _msg_exec=""
  local _regex=""
  local _results=""
  local _resultset=""
  local _text=""
  local _title=""
  local _width=""
  #
  local -a _list
  #
  _cache="$CACHEDIR/$FUNCNAME"
  _height="1000"
  _msg_exec="Execute command?$NL    (CANCEL will prompt to optionally delete the command from the list)$NL$NL"
  _text="Select command..."
  _title="Execute a Command    ($TITLE: $FUNCNAME())"
  _width="1000"
  #
  [[ "$*" =~ ^--  ]]  || _regex="$*"
  [[ "$_regex"    ]]  || _regex="$(optionArg --regex "$@")"
  #
  __="$(optionArg --title "$@")"; _title="${__:-$_title}"
  ### set title
  #
  isFileExists "$_cache"  || { abortShow filenotfound "Required cache file '$_cache' not found"; return; }
  #
  while read _a; do _list+=("$_a"); done < <(tac "$_cache" | grep -Ei "$_regex")
  ### read cache file contents into _list array
  ###   old versions of bash do not support the faster 'readarray' so using a loop
  #
  [[ "${_list[@]}"    ]]  || { gtkInfo "${NL}  No Matches Found";                             return $?; }
  ### return fail if no matches
  #
  _command="$(dialogSelect --text "$_text" --title "$_title" --width "$_width" --height "$_height" -- "${_list[@]}")"
  ### select cached command or enter a new one
  #
  [[ "${_command: -1}" == "|" ]]  && { _command="${_command%|}"; }
  ### strip off yad's trailing '|' if any
  #
  [[ "$_command" ]]  && {
    #
    _resultset="$( fileQuery --select --from "$_cache" --where "$_command" --like "$_command" )"
    ### see if command returned from dialogSelect is already cached
    #
    [[ "$_resultset" ]]  || { __="$(fileQuery --insert --into "$_cache" --set "$_command")"; }
    # [[ "$_resultset" ]]  || { fileQuery --insert --quiet --from "$_cache" --set "$_command_esc"; }
    ### if not found, add new command to cache
    #
    if gtkQuestion "$_msg_exec $_command" --width "$_width"
    then
      #
      exec $_command
      ### execute command
      #
      log --arguments "$_results"
      #
      return $?
    else
      fileQuery --delete --from "$_cache" --where "$_command" --like "$_command"  && {
        gtkInfo --title "$_title" --text "Deleted Command...${NL}    $_command"
        return 0
      }
      ### delete command from cache instead of executing
      #
      return 1
    fi
  }
  ###  dialogSelect button: Okay  (run command)
  #
  return $?
  ### dialogSelect button: Cancel  (or no command selected)
}

function gtkFileSelect () { aliasOf fileSelectShow "$@"; }

function gtkInfo () {
  fnInit "$FUNCNAME.20190505" "$@"  && return 0
  #
  local _text=""
  local _title=""
  #
  [[ "$1"        ]]  || { "$FUNCNAME" --help; return 0; }
  ### if no arguments, show --help
  #
  [[ "$1" =~ ^-- ]]  || _text="$1"
  [[ "$_text"    ]]  || _text="$(optionArg --text "$@")"
  ### if first arg is not an option, assume it to be the dialog text
  #
  _title="$(optionArg title "$@")"   || { _title="$TITLE:  $FUNCNAME"; }
  # _title="$(optionArg title "${@:2}")"   || { _title="$TITLE:  $FUNCNAME"; }
  #
  case $UI in
    CLI)
      printf "%s\n" "$_text$NL"
      ;;
    GUI)
      if isOverflow "$_text"
      then
        _geometry="$GEOMETRY_PL"
      else
        _geometry="$GEOMETRY_PS"
      fi
      #
      # inspVar DLG
      #
      case "$DLG" in
        yad*)
          yad           --geometry="$_geometry" --title="$_title" --text="$_text" --image="gtk-info" --center --borders=10   & ### background
          ;;
        zenity*)
          zenity --info --geometry="$_geometry" --title="$_title" --text="$_text"                                            & ### background
          ;;
        *)
          abortDLG
          # printf "%s\n" "$_msg$NL"
          ;;
      esac
      ;;
    LOG)
      log --status "$_text"
      ;;
    *)
      abortUI
  esac
  #
  return 0
}

function gtkList () { aliasOf dialogCombo "$@"; }

function gtkLogStatus () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local MSG="$1"
  #
  log --status "$MSG"
  gtkInfo "$MSG"
  #
  return
}

function gtkNotify () {
  fnInit "$FUNCNAME.20190908" "$@"  && return 0
  #
  local _add_2=""
  local _icon=""
  local _menu=""
  local _notifdir=""
  local _pid=""
  local _pipe=""
  local _text=""
  local _tip=""
  local _title=""
  #
  _notifdir="$(dirOpen "$HOMEDIR/cache/$FUNCNAME")"
  #
  _pipe="$(pipeOpen "$TMPDIR/${FUNCNAME}.pipe")"
  exec 3<> "$_pipe"
  #
  yad --notification --listen <&3 &
  _pid=$!
  #
  _title="<b><big>✔</big>--- TESTING NOTIFICATION ---</b>"
  _text="<tt><big>Green item\n<i>Yellow item</i>\n<b>Red item</b></big></tt>"
  #
  _icon="icon:gtk-yes"
  #
  _tip="tooltip:$_title \n$_text"
  #
  _menu+="menu"
  _menu+=":Say Hello!echo Hello"
  _menu+="|Notifications!rox $_notifdir"
  _menu+="|Close YAD Notify!kill -9 $_pid!gtk-quit"
  #
  # ARGS="$*"; inspVar ARGS $(compgen -v _)
  # ARGS="$*"; inspVar ARGS $(compgen -v | grep -E '^_')
  #
  echo "$_icon" >&3
  echo "$_tip"  >&3
  echo "$_menu" >&3
  #
  # return 0
  ### diagnostic
  #
  title="<b><big>✔</big> Testing notification                              </b>"
  text="<i>Using HTML markup</i>"
  add_2="⏏ Eject (right-click to open menu) "
  #print
  echo "icon:gtk-cdrom" >&3
  echo "tooltip:$title $progress \n\n$text\n\n$add_2" >&3
  echo "menu:Eject /dev/sr0!bash -c eject /dev/sr0!gtk-cdrom|Exit!quit!gtk-quit" >&3
  #
  case $UI in
    CLI)
      cat
      ;;
    GUI)
      case $DLG in
        yad*)
          yad --notification --listen &
          ;;
        zenity*)
          zenity --progress --display=":0" --title="$_title" --text="$_text"
          ;;
        *)
          abortDLG
          ;;
      esac
      ;;
    *)
      abortUI
  esac
  ### accept progress input ONLY FROM stdin
  #
  return $?
}

function gtkProgress () {
  fnInit "$FUNCNAME.20190708" "$@"  && return 0
  #
  local _title=""
  local _text=""
  local _max=
  #
  # echo "IN $FUNCNAME"  >&2
  ### diagnostic
  #
  _title="$(optionArg --title "$@")"  || { _title="$TITLE:  ${FUNCNAME[1]}"; }
  ### window title
  #
  _max="$(  optionArg --max   "$@")"  || { _max=100                        ; }
  ### (integer) maximum value of progress bar
  #
  _text="$( optionArg --text  "$@")"
  ### dialog text (prompt)
  #
  awk -v M=$_max '{ print ((NR/M)*100)%100  "\n" "# " $0 "\n" }'  < /dev/stdin |
    case $UI in
      CLI)
        cat
        ;;
      GUI)
        case $DLG in
          yad*)
            yad --progress --display=":0" --geometry="1000x450" --enable-log --log-expanded --title="$_title" --progress-text="$_text"
            # yad --progress --display=":0" --geometry="1000x450" --enable-log --log-expanded --title="$_title" --progress-text="$_text"  2>/dev/null  || {
            # yad --progress --display=":0" --geometry="1000x500" --enable-log --log-expanded --title="$_title" --progress-text="$_text"  2>/dev/null  || {
            #  yad --progress --display=":0" --title="$_title" --text="$_text"
            # }
            ;;
          zenity*)
            zenity --progress --display=":0" --title="$_title" --text="$_text"
            ;;
          *)
            abortDLG
            ;;
        esac
        ;;
      *)
        abortUI
    esac
  ### accept progress input ONLY FROM stdin
  #
  return $?
}

function gtkQuestion () {
  fnInit "$FUNCNAME.20200503" "$@"  && return 0
  #
  local _args=( "$@" )
  local _title=""
  local _text=""
  local _width=""
  local _msg=""
  local _ans=""
  #
  [[ "${_args[0]}" =~ ^-- ]]  || _text="${_args[0]}"
  # [[ "$1" =~ ^-- ]]  || _text="$1"
  #
  [[ "$_text"             ]]  || _text="$(optionArg --text "$@")" || { _text="Okay?"; }
  ### dialog text (if first argument is not an option assume it is _text)
  #
  _title="$(optionArg --title "$@")"  || { _title="$TITLE:  ${FUNCNAME[1]}"; }
  ### window title
  #
  _width="$(optionArg --width "$@")"  && { _width="--width $_width"; }
  ### window width
  #
  _msg="
${_title}

    ${_text} (y/N)? "
  #
  # _ARGS="$*"; inspVar --func _args[@] _args[0] _args[1] _args[2]
  #
  case $UI in
    CLI)
      printf "%s" "$_msg"
      _ans="$(inputCli)"
      case "$_ans" in
        y|Y) return 0;;
          *) return 1;;
      esac
      ;;
    GUI)
      _text="$(printEncoded "$_text")"
      ### escape special characters for GUI display
      #
      case $DLG in
        yad*)
          yad    --text="$_text?" --title="$_title" --display=":0" --borders=10 $_width --button=No!gtk-no!No:1 --button=Yes!gtk-yes!Yes:0
          ;;
        zenity*)
          zenity --question --text="$_text?" --title="$_title" --display=":0" $_width
          ;;
        *)
          abortDLG
          ;;
      esac
      ;;
    *)
      abortUI
  esac
  #
  return $?
}

function gtkSignalsDebug () { aliasOf gtkActionsGen "$@"; }

function gtkSpinner () {
  fnInit "$FUNCNAME.20190605" "$@"  && return 0
  #
  local _gtkdialog="$(which gtkdialog)"
  local _optionarg=""
  local _gtkspinner_TIP="Click to dismiss"
  local _gtkspinner_ICON="gtk-missing-image"
  local _gtkspinner_ICON_pref="${HOMEDIR}/icons/spinner.gif"
  # local _gtkspinner_ICON_pref="${HOMEDIR}/icons/Spinner.gif"
  local _msg="... W O R K I N G"
  local _cache="$LOGDIR/gtkSpinner.log"
  local _DIALOG=1
  local _SPLASHSCREEN=4
  local _typehint="${gtkdialog_wintype[DIALOG]}"
  local _spinner=""
  local _pid=
  # local _optionGtk2desklet="${GTK2DESKLET:+ --gtk-module=$GTK2DESKLET}"
  # local _path="${HOMEDIR}/cache"
  # local _file="gtkspinner"
  # local _cache="$_path/$_file"
  ### 20190605  OBSOLETE
  #
  kill -9 ${_pid:-$SPINNERPID} 2>/dev/null 1>&2
  ### always kill running spinner if there is one
  #
  _pid="$(optionArg --stop "$@")"          && { return 0                                 ; }
  ### explicit stop so we're done
  #
  if [[ "$_gtkdialog" ]]
  then
    isFileExists "$_gtkspinner_ICON_pref"  && { _gtkspinner_ICON="$_gtkspinner_ICON_pref"; }
    #
    _optionarg="$(optionArg --icon "$@")"  && { _gtkspinner_ICON="$_optionarg"           ; }
    #
    _optionarg="$(optionArg --tip  "$@")"  && { _gtkspinner_TIP="$_optionarg"            ; }
    #
    # _typehint=${gtkdialog_wintype[UTILITY]}
    # _typehint=${gtkdialog_wintype[SPLASHSCREEN]}
    # _typehint=${gtkdialog_wintype[DIALOG]}  || { _typehint=$_DIALOG                      ; }
    # _typehint=${gtkdialog_wintype[SPLASHSCREEN]}  || { _typehint=$_SPLASHSCREEN          ; }
    ### bash 3.2.39(1)-release on Ubuntu 8.04 on LX04 does not support associative arrays
    #
    export _spinner='
      <window title="'$TITLE':  '$FUNCNAME'" type-hint="'"$_typehint"'" border-width="10" theme-icon-size="6">
        <button tooltip-text=" '$_gtkspinner_TIP' " visible="true" relief="2">
          <input file>'$_gtkspinner_ICON'</input>
          <label>'"$_msg"'</label>
          <action signal="clicked" function="exit">0</action>
        </button>
      </window>
    '
    # export _spinner='
    #   <window title="'$TITLE':  '$FUNCNAME'" type-hint="'"$_typehint"'">
    #     <button tooltip-text=" '$_gtkspinner_TIP' " visible="true" relief="2">
    #       <input file>'$_gtkspinner_ICON'</input>
    #       <label>'"$_msg"'</label>
    #       <action signal="clicked" function="exit">0</action>
    #     </button>
    #   </window>
    # '
    ### generate GtkDialog markup
    #
    # echo "USING gtkdialog"  >&2
    ### diagnostic
    #
    gtkdialog $DEBUGOPT --center --program=_spinner  >>"$_cache" 2>&1 & ### in background
    # gtkdialog $DEBUGOPT --center --program=_spinner $_optionGtk2desklet         >>"$_cache" 2>&1 & ### in background
    # gtkdialog $DEBUGOPT --center --program=_spinner $_optionGtk2desklet --class keepabove  >>"$_cache" 2>&1 & ### in background
    ### [?] '--class keepabove' (added as a Group in /etc/xdg/templates/_root_.jwmrc) did not work
    ### use gtkdialog if available
  else
    # echo "USING xmessage"  >&2
    ### diagnostic
    #
    xmessage -center -buttons "Okay:0" -print -default Okay " W O R K I N G ..." & ### in background
    # xmessage -center -buttons "Okay:0" -print -default Okay " W O R K I N G ..." >>"$_cache" 2>&1 & ### in background
    ### use xmessage
  fi
  #
  _pid=$!
  #
  # ARGS="$*"; inspVar _pid _spinner _cache _gtkvars _optionGtk2desklet
  #
  printf "%d\n" $_pid
  ### print gtkdialog pid for capture by calling script
  #
  return 0
}

function gtkWarning () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _title=""
  local _msg=""
  local _climsg=""
  #
  _title="$(optionArg title "$@")"   || { _title="$TITLE:  ${FUNCNAME[1]}"; }
  # _title="$(optionArg title "${@:2}")"   || { _title="$TITLE:  Homebank"; }
  #
  # _msg="$(argNonOption 1  "$@")"
  #
  _msg="
  WARNING
    $_title
      $(optionArg --:1  "$@")
"
  #
  case $UI in
    CLI)
      printf "%s\n" "$_msg"
      ;;
    GUI)
      case $DLG in
        yad*)
          yad --display=":0" --title="$_title" --image="gtk-dialog-warning" --center --text="$_msg"  & ### background
          ;;
        zenity*)
          zenity --display ":0" --warning --title="$_title" --text="$_msg"                           & ### background
          ;;
        *)
          abortDLG
          ;;
      esac
      ;;
    LOG)
      log --status "$_msg"
      ;;
    *)
      abortUI
  esac
  #
  return 0
}


function guiError     () { aliasOf gtkError "$@"; }

function guiInfo      () { aliasOf gtkInfo "$@"; }

function guiList      () { aliasOf dialogCombo "$@"; }

function guiLogStatus () { aliasOf gtkLogStatus "$@"; }

function guiProgress  () { aliasOf gtkProgress "$@"; }

function guiWarning   () { aliasOf gtkWarning "$@"; }

function helpAll () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _pfx=""
  local _file=""
  local _metafile=""
  #
  _pfx="$(     optionArg --pfx  "$@")"
  ### optional prefix
  #
  yad --list --center --geometry=200x500 --separator=" " \
      --title="$CMD"                                 \
      --text="  Double-click for help ..."               \
      --column=function                                  \
      --button=gtk-cancel:1 --button=gtk-ok:0            \
      --dclick-action="meta %s"                          \
      $(functions)                                       & ### in background
      # $(UI=CLI; fnList --pfx "$_pfx")                    & ### in background
  ### pick list
  #
  return 0
}

function helpCmd () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _cmd="$1"
  local _msg=""
  local _typ=
  local _rc=
  #
  _typ="$(cmdType $_cmd)"
  #
  # ARGS="$*"; inspVar ARGS _typ
  #
  case $_typ in
    file)
      _rc=0
      #
      _msg="$($_cmd --help 2>&1)" ||
        { _msg="$_cmd --help $(printAt 4 "$_msg")"; _msg+="$NL$NL$_cmd -h $(printAt 4 "$($_cmd -h 2>&1)")"; }
      # _msg="$($_cmd --help 2>&1)"
      ### external command
      ### some cmds treat help as failure and return false
      ### also may print an error message on stderr
      #
      # inspVarShow _cmd _msg _rc
      #
      ;;
    'builtin|keyword')
    # builtin|keyword)
      _msg="$(help  $_cmd  2>&1)"; _rc=0
      ### bash command or keyword
      ;;
    *)
      _rc=1
      ### no help
      ;;
  esac
  #
  # inspVarShow _cmd _typ _msg _rc
  #
  [[ "$_msg" ]]     && { printf "%s" "$_msg"; }
  #
  return $_rc
  ### 20160314  always show results, even errors
}

function helpHtml () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _file="$1"
  local _msg=
  local _type=
  #
  _type="$(file --brief $_file)"
  #
  # inspVarShow _file _type
  #
  [[ "$_type" != 'HTML document text' ]]  && { return 1; }
  #
  defaultbrowser "$_file"
  #
  return 0
}

function homebank () {
  fnInit ${FUNCNAME} "$@" --help-text="
homebank SUBJECT [OPTION...]
    Homebank finance.
    Revised:
        20161220 by docsalvager
" && return 0
  #
  gtkWarning --title "Kit:  Homebank" -- "
  If Homebank says the data file is invalid,
  it is probably due to differences in versions.

  Go to the menu...
      File >> Open.

  It should open to the directory...
      $HOME/.homebank
  or the link to it at...
      $HOME/.config/homebank

  Choose the .xhb data file, such as...
      Alpha.xhb

  File should open normally.

  Save it.

  ----------------------------------------

  REMINDER TO SELF...

    Remember to leave funds for groceries &amp; Rx!

"
  #
  command homebank --display=":0"  & ### background
  ### call external command 'homebank'
  ### (instead of endlessly calling this function till crash)
  #
  return $?
}

function inLOG () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ $UI == LOG ]] && return 0
  return 1
}

function inCLI () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ $UI == CLI ]] && return 0
  return 1
}

function inGUI () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ $UI == GUI ]] && return 0
  return 1
}

### 20180212  OBSOLETE
###   Use source
#
# function include () {
#   fnInit ${FUNCNAME} "$@"  && return 0
#   #
#   T="${T}  "
#   #
#   # No function-specific options
#   if isAnOption "$1"
#   then
#     echo "${T}Unknown option: $@"
#   else
#     local FILE="$(basename $1)"
#     local DIR="$(pathName "$(which $0)")"
#     #
#     # callInspect "$@"
#     # echo "${T}DIR/FILE      : $DIR/$FILE"
#     #
#     # source "$DIR/$FILE"  # 2>/dev/null
#     #
#     if source "$DIR/$FILE"  # 2>/dev/null
#     then
#       return 0
#     else
#       # exit
#       printf "${T}$DIR/$FILE not found\n\n"
#       include --help
#       return 1
#     fi
#   fi
#   #
# }

function indentStr () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _str="$@"
  #
  # inspVarShow _str
  #
  echo "${_str%%[^[:space:]]*}"
}

function inputCli () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _input=""
  local _prompt=""
  #
  [[ "$1" =~ ^-- ]]  || _prompt="$1"
  [[ "$_prompt"  ]]  || _prompt="$(optionArg --prompt "$@")"
  ### if first arg is not an option, assume it to be the prompt
  #
  [[ "$_prompt" ]]  && { printf "%s" "$_prompt" > /dev/tty; }
  ### no prompt at all if none supplied
  #
  _input="$(awk 'BEGIN {getline INPUT < "/dev/tty"; print INPUT}')"
  ### accept input (used in place of 'read')
  ###   put in a BEGIN section so will only accept 1 line and exit on ENTER
  ###   WAITS INDEFINITELY FOR INPUT
  #
  [[ "$_input" ]]  && { printf "%s" "$_input"; return 0; }
  #
  return 1
}

function inputStdin () { aliasOf stdinInput "$@"; }

function inspArg () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _arg=""
  local _i=1
  local _text=""
  #
  for _arg in "$@"
  do
    _text+="\$${_i} =$(printAt 2 "'${_arg}'")$NL"
    ((++_i))
  done
  #
  printf "%s\n" "$_text"
  return 0
}

function inspArgShow () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _caller=""
  local _callerstr=""
  # local _fn=${FUNCNAME[1]}; [[ $_fn =~ source|main ]]  || _fn+="()"
  #
  # _caller="${_caller##* }.$_fn {${_caller%% *}}"
  #
  _callerstr="$(inspCaller "$(caller 0)")"
  #
  # inspVarShow _caller _callerstr
  #
  [[ ${FUNCNAME[1]} != dialog ]]  && { dialog --title="Arguments at:  $_callerstr" -- "$(inspArg "$@")"; return 0; }
  #
  yad --text="Dialog window function (dialog) arguments must be listed on commandline in terminal."
  ### calling from within dialog causes a circular reference so just list in terminal
  #
  inspArg "$@"
  return 1
}

function inspCaller () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _caller="$1"
  local _callerstr=""
  # local _fn="${FUNCNAME[1]}"; [[ "$_fn" =~ source|main ]]  || _fn+="()"
  # local -i _frame="$(optionArg frame "$@")"; _frame="${_frame:-1}"
  #
  _callerstr="$(echo $_caller | awk '{print $3 "{" $1 "}." $2}')"
  # _caller="$(caller $_frame)"
  # _caller="${_caller##* }.$_fn {${_caller%% *}}"
  #
  # inspVarShow _caller _callerstr
  #
  printf "%s" "$_callerstr"
  return 0
}

function inspFn () {
  fnInit "$FUNCNAME.20190726" "$@"  && return 0
  #
  local _cmd="$1"                               ### command being processed (CMD[0])
  local _fn2="$2"                               ### function to inspect
  local _fn1="$3"                               ### calling function of function to inspect
  local _argsfrag="$4"                          ### first INSPFRAGLEN characters of _argsline(ARGSLINE)
  local _call=                                  ### function call array index (self=0)
  local _line=""                                ### source script line number
  local _src=""                                 ### source script
  local _timelast=$TIMELAST                     ### time in milliseconds since epoch of last call
  local _timelapsed=                            ### time in milliseconds elapsed since last call
  local _timenow=$(timeMs)                      ### time in milliseconds since epoch
  local _top=$((${#FUNCNAME[@]}-1))             ### function stack top item number
  #                                             ###   inspFnStackTop() would cause cir_ref
  _timelapsed=$(( _timenow - _timelast ))
  ### elapsed time
  ###   per bash manpage... Arithmetic Expansion $((...)), ARITHMETIC EVALUATION ...
  ###     - '$' is optional
  ###     - variables may be strings or integers but always interpreted as integers
  ###     - null variables interpreted as integer 0
  ###
  ### Note that this copy of $TIMELAPSE is local since inspFn()
  ### is usually called via command-substitution (e.g. in a subshell)
  ### For approximate elapsed time between calls to this function,
  ### reset $TIMELAPSE in calling function as in...
  ###   [[ "$INSPECT" ]]  && {  TIMELAPSE=$(timeMs); INSPECT+="$(inspFn "$@")$NL"; TIMELAPSE=$(timeMs); }
  ###
  #
  for (( _call=1; _call <= _top; ++_call ))
  do
    [[ "${FUNCNAME[$_call]}" == "$_fn1" ]]  && break
  done
  ### find _call number of function to be inspected
  #
  _src="$(hostname):${BASH_SOURCE[$_call+1]}"
  # _src="${BASH_SOURCE[$_call+1]}"
  #
    _line="${BASH_LINENO[$_call]}"
  #
  _argsfrag="${_argsfrag:0:$INSPFRAGLEN}"
  #
  # inspVar _argsline _argsfrag
  #
  printf "%5dms  %s{%05d}:  %10.10s  %10.10s  %s$NL" "$_timelapsed" "$_src" "$_line" "$_cmd" "$_fn2" "$_argsfrag"
  # printf "%5dms %15s{%05d}: %s$NL" "$_timelapsed" "$_src" "$_line" "$_argsfrag"
  ### print stats and up to _fraglen characters of the argument list
  #
  [[ "$INSPECT" == "2" ]]  && { printAt 11 "$(inspFnStack "$_fn1")$NL"; }
  # [[ "$INSPECT" == "2" ]]  && { printAt 32 "$(inspFnStack "$_fn")"; }
  #
  return 0
}

function inspFnLineage () {
  fnInit "$FUNCNAME.20190223" "$@" && return 0
  #
  printf "%s$NL    " "$(timeDate)"                                              >&2
  printf ".%s"       $(echo "${FUNCNAME[@]:1}" " " | tac --separator=" ") "$NL" >&2
  # printf ".%s" $(echo "${FUNCNAME[@]:1}" " " | tac --separator=" ") "$NL" >&2
  printf "        %-80s$NL"  "${@:1:1}  {${BASH_LINENO[2]}}"                    >&2
  printf "        %-80s$NL"  "${@:2}"                                           >&2
  printf "$NL"                                                                  >&2
  ### print complete function lineage and arguments to stderr (commandline)
}

function inspFnStack () {
  fnInit "$FUNCNAME.20180208" "$@" && return 0
  #
  local T+="  "
  local _at=
  local _text=""
  local _level="$(inspFnStackTop)"
  local _fn=""
  local _sfx=""
  #
  _fn="${1:-$FUNCNAME[1]}"; [[ "$_fn" =~ source|main ]]  || _sfx="()"
  # _fn="${1:-$FUNCNAME[1]}"; [[ "$_fn" =~ 'source|main' ]]  || _fn+="()"
  ### function to inspect in reference to
  #
  # inspVar _level
  #
  let _level=_level+1
  ### post-decrement _level
  #
  _text+="$_level level function call stack for $_fn$_sfx ...\n"
  _text+="| L   BASH_SOURCE{BASH_LINENO called from}.FUNCNAME  \n"
  _text+="| ---------------------------------------------------\n"
  #
  while (( $_level > 3 ))
  # while (( $_level > 0 ))
  do
    _text+="| $_level ${T}$(inspFnStackItem $_level)$NL"
    T+="  "
    let _level--
  done
  #
  printf "$_text$NL"
  #
  return 0
}

function inspFnStackItem ()  {
  fnInit "$FUNCNAME.20190726" "$@"  && return 0
  #
  local _at=""
  local _fn=""
  local _i=$1
  local _item=""
  local _sfx=""
  #
  _fn=${FUNCNAME[$_i]}; [[ "$_fn" =~ source|main ]]  || _sfx+="()"
  # local _fn=${FUNCNAME[$_i]}; [[ $_fn =~ 'source|main' ]]  || _fn+="()"
  ### append '()' to function names
  #
  _at="${BASH_LINENO[$_i-1]}"; [[ $_at == 1 ]]  && _at="trap"
  ### line number
  #
  _item="${HOST}:${BASH_SOURCE[$_i]}{${_at}}.$_fn$_sfx"
  # _item="${BASH_SOURCE[$_i]}{${_at}}.$_fn$_sfx"
  ### build item - host:file{at}.function
  #
  printf "%s" "$_item"
  return 0
}

function inspFnStackTop () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  printf "%d\n" $(( ${#FUNCNAME[@]} - 2 ))
  ### top stack item is 2 less than length of FUNCNAME array stack
  ### it is 2 instead of 1 due to being a zero-based array
  #
  return 0
}

function inspVar () {
  fnInit "${FUNCNAME}.20190427" "$@"  && return 0
  #
  local _iv__=""
  local -a _iv_args
  local _iv_fn=""
  local _iv_fc=""
  local _iv_msg=""
  local _iv_opt=""
  local _iv_pfx=""
  local _iv_prt=()
  local _iv_var=""
  local _iv_val=""
  #
  if [[ "$1" =~ ^-- ]]
  then
    _iv_opt="$1"
  else
    _iv_opt="--var"
  fi
  #
  _iv_fn+="${FUNCNAME[1]}"; [[ "$_iv_fn" =~ source|main ]]  || _iv_fn+="()"
  _iv_fc+="${FUNCNAME[2]}"; [[ "$_iv_fc" =~ source|main ]]  || _iv_fc+="()"
  #
  _iv_msg+="${NL}$(timeDate) [${HOST}:${BASH_SOURCE[1]} (${BASH_LINENO})] $_iv_fc ==> $_iv_fn ...$NL"
  #
  # _iv_args=""
  case "$_iv_opt" in
    --all)
      _iv_args+=( $(compgen -v | sort) )
      # _iv_args="$(compgen -v | sort)"
      ;;
    --func)
      _iv_args=( $(optionArg --func "$@") )         ### explicitly listed vars
      _iv_args+=( "${!_@}" )                          ### local (_*) vars
      ### THIS IS CORRECT (I think)
      # IFS=$'\n'; _iv_args=( $(optionArg --func "$@") ); IFS="$IFSDEF"         ### explicitly listed vars
      # _iv_args=( $"$(optionArg --func "$@")" )         ### explicitly listed vars
      # IFS=$'\n'; _iv_args=( $(optionArg --func "$@") ); unset IFS         ### explicitly listed vars
      # _iv_args=( $"$(optionArg --func "$@")" )         ### explicitly listed vars
      #
      # _iv_args+=( $"${!_@}" )                          ### local (_*) vars
      # _iv_args=( ${!_@} )                        ### local (_*) vars
      # printf "%s\n" "$_iv_args}" >&2
      #
      # printf "%s\n" "${_iv_args[@]}" >&2
      # _iv_args=( ${!_@} )                        ### local (_*) vars
      # _iv_args+=( $(optionArg --func "$@") )      ### explicitly listed vars
      # _iv_args+=" $(compgen -v _)"
      ### print passed variables and all '_' prefix variables (i.e. local)
      ;;
    --script)
      _iv_args+=( $( comm -1 -3 <(sort <<< "$ENVVARS") <(compgen -v | sort) ) )
      ### NOTE
      ###   Quoting "$(...)" would return 1 array element instead of multiple
      ###   Spaces in variable values are preserved by optionArg()
      ;;
    --pfx)
      _iv_pfx="$(optionArg --pfx:1 "$@")"
      _iv_args+=( $(compgen -v $_iv_pfx) )
      # _iv_args="$(compgen -v $_iv_pfx)"
      ;;
    --var)
      _iv_args+=( $(optionArg --var "$@") )
      # if isOption --var "$@"
      # then
      #   _iv_args+=( $(optionArg --var "$@") )
      # else
      #   _iv_args+=( $(optionArg --var "--var" "$@") )
      # fi
      # _iv_args+=( $(optionArg --var "--var" "$@") ) ### force --var option
      ### NOTE
      ###   Quoting "$(...)" would return 1 array element instead of multiple
      ###   Spaces in variable values are preserved by optionArg()
      ;;
    *)
      return 1
      ;;
  esac
  #
  # dialog --wrap -- "${#_iv_args[@]} variables visible to $FUNCNAME called from $_iv_fn at line ${BASH_LINENO}...$NL$NL${_iv_args[@]}"
  ### DIAGNOSTICS
  #
  # for _iv_var in ${_iv_args[@]}
  for _iv_var in "${_iv_args[@]}"
  do
    #
    # echo "_iv_var: $_iv_var"  >&2
    # __="${!_iv_var}"; echo "  arrsub: ${__[0]}"  >&2
    ### diagnostics
    #
    [[ "$_iv_var" =~ ^_iv_ ]]  && continue
    ### exclude inspVar variables
    #
    # printf "%s (len: %d)\n" "${_iv_var[@]}" "${#_iv_var[@]}"  >&2
    # _iv_prt="${!_iv_var}"; printf "  %s (len: %d)\n" "${_iv_prt}" ${#_iv_prt[@]}  >&2
    # printf "DEBUG: %s\n" "${!_iv_var}" >&2
    ### DIAGNOSTICS - NOT RELIABLE - NOT SHOWING LENGTH OF ARRAYS
    #
    _iv_val="$( printf "%s\n" "${!_iv_var}" | awk '{printf("%5d:  %s\n",NR-1,$0)}' )"
    ##_iv_val="$( printf "%s\n" "${!_iv_var}" | awk '{printf("%5d:  %s\n",NR,$0)}' )"
    # _iv_val="$( printf "%s\n" ${!_iv_var} | awk '{printf("%5d:  %s\n",NR,$0)}' )"
    # _iv_val="$( printf "%s\n" "${!_iv_var}" | awk '{printf("%5d:  %s\n",NR,$0)}' )"
    # _iv_val="$( awk '{printf("%5d:  %s\n",NR,$0)}' <<< "${!_iv_var[@]}" )"
    # _iv_val="$( printf "%s\n" "${!_iv_var[@]}" | awk '{printf("%5d:  %s\n",NR,$0)}' )"
    #-_iv_val="$( printf "%s\n" "${!_iv_var[@]}" | awk '{printf("%5d:  %s\n",NR,$0)}' )"
    #-_iv_val="$( _iv_var_val="${_iv_var}"; printf "%s\n" "${!_iv_var_val[@]}" | awk '{printf("%5d:  %s\n",NR,$0)}' )"
    ### _iv_val will contain one or more lines, prefixed with the line#
    ###   which corresponds to ONE GREATER THAN the array element# (always?)
    #
    (( $(wc -l <<< "$_iv_val") == 1 ))  && { _iv_msg+="\$$_iv_var =$NL$(printAt 2 "'${!_iv_var}'")$NL"; continue; }
    # (( $(lineCount "$_iv_val") == 1 ))  && { _iv_msg+="\$$_iv_var =$NL$(printAt 2 "'${!_iv_var}'")$NL"; continue; }
    # (( $(lineCount "${_iv_val[@]}") == 1 ))  && {
    #   _iv_msg+="\$$_iv_var =$NL$(_iv__="${!_iv_var}"; printAt 2 "'${_iv__[@]}'")$NL"; continue
    #   # (( $(lineCount "$_iv_val") == 1 ))  && { _iv_msg+="\$$_iv_var =$NL$(printAt 2 "'${!_iv_var}'")$NL"; continue; }
    # }
    ### oneline
    ###   use printAt() instead of spaces for correct indentation with multiline vars
    #
    _iv_msg+="\$$_iv_var =$NL${_iv_val}$NL"  || { abortShow outofmemory "Error code $?. Memory status...$NL$(printAt 4 "$(memory)")"; }
    ### multiline
  done
  #
  printf "%s\n" "$_iv_msg"         >&2
  ### print to stderr
  #
  return 0
}

function inspVarShow () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _ivs_caller=""
  local _ivs_fn=""
  local _title=""
  local _vars=""
  #
  _ivs_caller="$(caller)"
  _ivs_caller="${_ivs_caller#* }"
  #
  _ivs_fn="${FUNCNAME[1]}"
  [[ "$_ivs_fn" =~ 'source|main' ]]   || _ivs_fn+="()"
  #
  _title="Variables at:  ${_ivs_caller}.${_ivs_fn}"
  _vars="$(inspVar "$@" 2>&1)"
  #
  [[ "${FUNCNAME[1]}" != 'dialog' ]]  && { dialog --title="$_title" -- "$_vars"; return 0; }
  #
  yad --text="Dialog window function (dialog) variables must be listed on commandline in terminal."
  ### calling from within dialog causes a circular reference so just list in terminal
  #
  printf "%s\n" "$_vars"
  return 1
}

function inspect () {
  fnInit "${FUNCNAME}.20190726" "$@"  && return 0
  #
  local T+=""
  local _fn="${FUNCNAME[1]}"
  local _out=""
  local _vars=""
  local _totalelapsed=""
  local _cachefile="$INSPFILE"
  #
  printf "${T}%s$NL" "${CMD[0]}"
  printf "${T}  %s$NL" "${CMD[@]:1}"
  #
  printf "%s$NL" "
--- FUNCTION CALLS -------------------------------------------------------------

elapsed  before start of script{line}...    CMD...      Caller...   Fn & Args...
-------  -----------------------------------------------------------------------..."
  printf "%s$NL" "$(cat $_cachefile)
-------"
  ### function calls accumulated into $INSPFILE by inspFn() that is called by fnInit()
  #
  _totalelapsed=$(( $(timeMs) - $TIMESTART ))
  ### total elapsed time since start of script
  #
  printf "% 5dms  %s$NL" "$_totalelapsed" "Total Elapsed Time"
  # printf "% 5dms  %20s$NL" "$_totalelapsed" "Total Elapsed Time"
  #
  printf "%s$NL" "

--- SELECTED GLOBALS -----------------------------------------------------------
"
  T+="  "
  printf -v _vars "${T}%-30s:  %s\n"                         \
    "\$0"                               "$0"                 \
    "Arguments (\$*) to inspect()"      "$*"                 \
    "CACHEDIR"                          "$CACHEDIR"          \
    "CMD[0]"                            "${CMD[0]}"          \
    "BASH_SOURCE[1]"                    "${BASH_SOURCE[1]}"  \
    "Called From \$(caller)"            "$(caller)"          \
    "DLG"                               "$DLG"               \
    "File exts ignored (FIGNORE)"       "$FIGNORE"           \
    "HELPFONT"                          "$HELPFONT"          \
    "HOMEDIR"                           "$HOMEDIR"           \
    "INSPECT level"                     "$INSPECT"           \
    "LOGDIR"                            "$LOGDIR"            \
    "kit_CONF"                          "$kit_CONF"          \
    "kit_VERSION"                       "$kit_VERSION"       \
    "METAFILE"                          "$METAFILE"          \
    "TMPDIR"                            "$TMPDIR"            \
    "UI"                                "$UI"
  printf "%s$NL" "$_vars"
  #
  printf "%s$NL" "
--- MEMORY ---------------------------------------------------------------------

$(memory)"
  #
  printf "%s$NL" "
--- BASH SETTINGS (set -o) -----------------------------------------------------
"
  printf "%s$NL" "$(set -o)$NL"
  printf "%s$NL" "
--- BASH OPTIONS (shopt) -------------------------------------------------------
"
  printf "%s$NL" "$(shopt)$NL"
  #
  # printf "%s${NL}" "$_out"
  #
  return 0
}

function inspectRevisions () {
  fnInit "$FUNCNAME.20180208" "$@"  && return 0
  #
  local __=""
  local _count=""
  local _function=""
  local _list=""
  local _metafile=""
  local _reSection=""
  local _revdate=""
  local _search=""
  local _selected=""
  local _sorted=""
  local _text=""
  local _title=""
  #
  _reSection="^REVISED"
  _text="Select function to show bash internal representaion (no comments)"
  _title="$FUNCNAME  (per $kit_META)"
  ### initializaton
  #
  _metafile="$(optionArg metafile "$@")"
  _metafile="${_metafile:-$METAFILE}"; [[ "$_metafile" ]]  || { return 1; }
  ### requires default meta file if not supplied
  #
  _list="$(
    awk -v reVarEq="$reVarEq" -v section="$_reSection" '
      $0 ~ reVarEq  {split($0,a,"="); var=a[1]; sub(/_help/,"",var)};
      $0 ~ section  {getline; printf "%s  %s\n",$1,var};
    ' "$_metafile"
  )"                                                       || { return 1; }
  ### list all varibles in format "variable-name revised-date"
  #
  _list="$(
    IFS=$'\n'
    for _function in $_list
    do
      if [[ "$_function" =~ ^\$_revised ]]
      then
        __="${_function##* }"
        #
        _revdate="$( kit $__ --revised 2>/dev/null)"
        #
        [[ "$_revdate" ]]  && { echo "$_revdate  $__"; }
      else
        echo "$_function"
      fi
    done
  )"
  ### get revision date via --revised option if not in METAFILE
  #
  #
  ### Limit Selection
  #
  _search="$(optionArg --search  "$@")" && { _list="$(grep --ignore-case --word-regexp "$_search" <<< "$_list")"; }
  # _search="$(optionArg --search  "$@")" && { _list="$(grep -i "$_search" <<< "$_list")"                  ; }
  ### list only those matching _search string
  #
  _count="$(optionArg --recent  "$@")"  && { _selected="$(sort -r  <<< "$_list" | head -n${_count:=20})"        ; }
  ### list most recently revised numberof (default=20)
  #
  _count="$(optionArg --oldest  "$@")"  && { _selected="$(sort     <<< "$_list" | head -n${_count:=20})"        ; }
  ### list oldest revised numberof (default=20)
  #
  _selected="${_selected:-$_list}"
  ### unlimited
  #
  #
  ### Sort Results
  #
  # isOption --sorted   "$@"              && { _selected="$(sort     <<< "$_selected")"; dialogSelect -- "$_selected"; return $?; }
  ### forward sort by date,name
  #
  isOption --sorted-by-name   "$@"  && { _sorted="$(sort -k2 <<< "$_selected")"; }
  # isOption --sorted-by-name   "$@"  && { _sorted="$(sort -k3 <<< "$_selected")"; }
  ### forward sort by date,name
  #
  isOption --reversed         "$@"  && { _sorted="$(sort -r  <<< "$_selected")"; }
  ### reverse sort by date,name
  #
  isOption --sorted           "$@"  && { _sorted="$(sort     <<< "$_selected")"; }
  ### sort by revision date (first column), name
  #
  _sorted="${_sorted:-$(sort <<< "$_selected")}"
  ### default order is --sorted by revision date (first column), name
  #
  fnShow "$(
    dialogSelect --title="$_title" --text "$_text" --column "Revised" "Function" "$@" \
      -- "$_sorted" | awk -F '|' '{print $2}'
  )"
  ### Show Results
  #
  return 0
}

function inspectShow () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  dialog --title="Inspect Diagnostics" -- "$(inspect "$@")"
  #
  return 0
}

function  insureDir () {
  fnInit "$FUNCNAME.20180208" "$@"  && return 0
  #
  local DIR=$1
  #
  if isDirExists $DIR
  then
    return 0
  else
    # if dir create fails, return false. Otherwise true
    return $(mkdir $DIR 2>/dev/null)
  fi
}

function  insureFile () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local FILE=$1
  if isWritable $DIR
  then
    return 0
  else
    # if file create fails, return false. Otherwise true
    return $(>$FILE)
  fi
}

function isAnOption () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ "$1" =~ ^-- ]]  && return 0
  ### begins with a double-hyphen so is an option
  #
  return 1
  ### anything else is not an option
}

function isArgsNone () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ $(argsNumber "$@") == 0 ]]  && return 0
  return 1
}

function isCommand () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _arg=" $(cmdType "$1") "
  local _executables=' alias builtin file function keyword '
  #
  # inspVar _arg _executables
  #
  isIn "$_arg" "$_executables"  && return 0
  #
  return 1
}

function isDir () { aliasOf isDirExists "$@"; }
### DEPRECATED

function isDirExists () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ -d "$1" ]]  && return 0
  return 1
}

function  isDirWrite () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ -d $1 ]] && [[ -w $1 ]] && return 0
  return 1
}

function isExecuted () {
  fnInit "${FUNCNAME}.20190206" "$@"  && return 0
  #
  [[ "${FUNCNAME[1]}" == "source" ]]  && { return 1; }
  ### the caller "function" name in ${FUNCNAME[1]} will be...
  ###   "source"     if sourced
  ###   "main" or "" if executed
  #
  return 0
  ### executed
}

# function isExists () { aliasOf isFileExists "$@"; }
### 20180406  renamed isFileExists (test -e) to isExists

function isFile () { aliasOf isFileExists "$@"; }

function isFileAny () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  compgen -A file "$1" >/dev/null  && return 0
  return 1
}

function isExists () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ -e "$1" ]]  && return 0
  return 1
}

function isFileExec () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ -x "$1" ]]  && return 0
  return 1
}

function isFileExists () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ -f "$1" ]]  && return 0
  return 1
}

function isFileLink () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ -L "$1" ]]  && return 0
  return 1
}

function  isFileNonNull () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ -s "$1" ]]  && return 0
  return 1
}

function  isFileRead () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ -r "$1" ]]  && return 0
  return 1
}

function isFileRegular () { aliasOf isFileExists "$@"; }

function isFileRemote () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _file="$1"
  local _msg=""
  local _rc=
  local _logfile="$LOGFILE"
  #
  _msg="$(df -l "$_file" 2>&1)"; _rc=$?
  #
  # echo -e "
  errorShow unspecified "
--<{( E X P E R I M E N T A L )}>--

$FUNCNAME $*

--- df -l Output -------------------------------------------
$_msg
------------------------------------------------------------
Return Code of 'df -l': $_rc
Return Code of $FUNCNAME: $(( _rc == 0 ? 1 : 0 ))
"
# " >>$_logfile
  #
  # : $_rc  && return 0
  ### _file is local
  ### 'df -l' returns a non-zero exit code if the file or directory is not local
  ### per http://stackoverflow.com/questions/12256925/detecting-a-remote-mount
  #
  return $(( _rc == 0 ? 1 : 0 ))
  ### reverse logic
}

function  isFileWrite () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ -w "$1" ]]  && return 0
  return 1
}

function isFnLoaded () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _fn="$1"
  #
  # [[ "$_fn" =~ ^--function= ]]  && { _fn="${_fn#--function=}"; }
  ### support things like _var="$(isFnLoaded --function=fnShow ...
  #
  [[ ("$_fn" == "") || ("$_fn" =~ ^-)  ]]  && { return 1; }
  ### ignore any other option type
  #
  [[ "$(cmdType "$_fn")" != "function" ]]  && { return 1; }
  ### not a functon
  #
  return 0
}

function isFound () { aliasOf isExists "$@"; }
# function isFound () { aliasOf isFileExists "$@"; }

function isIn () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _sub="$1"; shift
  local _str="$*"
  #
  [[ "${_str#*$_sub}" != "$_str" ]]  && return 0
  ### if $_sub is NOT in $_str, the two strings will be identical
  #
  return 1
}

function isInteractive () { aliasOf isInteractiveTTY "$@"; }

function isInteractiveOPT () {
  fnInit ${FUNCNAME} "$@" --help-text="
isInteractiveOPT
    The list of active bash options and set values contains 'i' for interactive.
    Revised:
        20160826 by docsalvager
" && return 0
  #
  local bash_options_sets="$-"
  #
  # ARGS="$*"; inspVar ARGS bash_options_sets
  #
  [[ "$bash_options_sets" =~ i ]]  && return 0
  ### the list of active bash options and set values contains 'i'
  #
  return 1
}

function isInteractivePS1 () {
  fnInit ${FUNCNAME} "$@" --help-text="
isInteractivePS1
    This widely used test...
      if [[ -z \"\$PS1\" ]]
    may be unreliable since things like SSH sftp connections, use their own
    internal commandline instead of using a tty so 'tty -s' returns false(1).
    WARNING:
        In kit, \$PS1 is always null. At the moment do not know why. Don't use.
    Revised:
        20160826 by docsalvager
" && return 0
  #
  [[ "$PS1" ]]  && return 0
  #
  return 1
}

function isInteractiveTTY () {
  fnInit ${FUNCNAME} "$@" --help-text="
isInteractiveTTY
    The 'tty -s' command returns true(0) if in an interactive session (a shell
    command line) since a tty is in use. Otherwise false(1).
    The widely used test...
      if [[ -z \"\$PS1\" ]]
    ... is unreliable since things like SSH sftp connections, use their own
    internal commandline instead of using a tty so 'tty -s' returns false(1).
    See also:
        isTTY
    Revised:
        20170106 by docsalvager
" && return 0
  #
  return $(tty -s)
}

function isLinesExceeds () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _max="$1"
  local _line=""
  local _i=0
  #
  [[ "$_max"  ]]  || { $FUNCNAME --help; return 0; }
  #
  [[ "${@:2}" ]]  || {                   return 1; }
  #
  for (( _i=0; _i > _max; ++_i ))
  do
    read _line
    [[ "$_line" ]] || break
  done < <(printf "%s" "$@:2")
  #
  # while read _line
  # do
  #   ((_i > _max)) && break
  #   ((++_i))
  # done < <(printf "%s" "$@:2")
  #
  echo "\$@:2:  ${@:2}"
  echo "_i:  $_i"
  #
  ((_i > _max)) && return 0
  #
  return 1
}

function isLink () { aliasOf isFileLink "$@"; }

function isLinkBroken () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _link="$1"
  #
  [[ "$(find "$_link" -xtype l 2>&1)" ]]  && return 0
  #
  return 1
}

function isListed () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ $(listIndex "$1" "${@:2}") > 0 ]] && return 0
  return 1
}

function isLogin () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  shopt -q login_shell  && return 0
  return 1
}

function isNotEmpty () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  return $(test -s $1)
}

function isNotNull () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ -n "$1" ]]  && return 0
  return 1
}

function isNoOptions () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _re='\s?--' ### begins with '--' or word in string begins with '--'
  #
  [[ "$*" =~ $_re ]]  && return 1
  ### no argument begins with a double-hyphen there are no options
  #
  return 0
  ### there ARE options
}

function isNotOption () { ! isAnOption "$@"; }

function isNull () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ -z "$1" ]]  && return 0
  #
  return 1
}

function  isOption () {
  fnInit "$FUNCNAME.20190513" "$@"  && return 0
  #
  local __=""
  #
  ####### optionArg "$@" >/dev/null  && { printf "%s$NL" "$_find"; return 0; }
  #
  __="$(option "$@")"               && return 0
  # optionArg "$@" 1>/dev/null 2>&1  && { return 0; }
  ### check for option and discard the option name returned by option()
  ###   Reliably detecting an actual --option while ignoring embedded text is
  ###   handled in the optionArg() parsing loop that is called by option().
  ###   Tests indicate there is no appreciable performance improvement
  ###   seen by eliminating the option-argument code in optionArg().
  #
  return 1
}

function isOverflow () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local SIZE="${#*}"
  local LINES=$(lineCount "$@")
  #
  (( SIZE   > TEXTMAXSMALL ))  && return 0
  (( LINES  > GEOMETRY_CSH ))  && return 0
  #
  return 1
}

function  isPipeExists () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  test -p "$1"  && return 0
  return 1
}

function isPortOpen () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _port="$(optionArg port "$@")"
  local _addr="$(optionArg addr "$@")"
  #
  # port is open
  (echo >/dev/tcp/${_addr}/${_port})  && return 0
    # (echo >/dev/tcp/${_addr}/${_port}) >/dev/null 2>&1  && return 0
  #
  # port is closed
  return 1
}

function isRecursive () {
  [[ ${FUNCNAME[1]} != "fnInit" ]]  && { fnInit ${FUNCNAME} "$@"  && return 0; }
  #
  local -i _rc=1
  #
  local _test_fn="${FUNCNAME[1]}"
  local _top=$(callStackTop)
  #
  # inspVar FUNCNAME[1] _top _test_fn
  # inspVarShow   FUNCNAME[2] _top _test_fn
  #
  ### Does function we were called from appear higher up in the function stack?
  ### Function call Stack...
  ###         $_top   6
  ###   FUNCNAME[5]   5   main
  ###   FUNCNAME[4]   4     <function4>-----\  if any of these 3 equal the value
  ###   FUNCNAME[3]   3       <function3>----| of $_test_fn, then that function
  ###   FUNCNAME[2]   2         <function2>-/  is recursive.
  ###   FUNCNAME[1]   1           $_test_fn
  ###   FUNCNAME[0]   0             isRecursive
  ###
  for (( i=2; i<_top; ++i ))
  do
    #
    # echo "$i  ${FUNCNAME[$i]}" >&2
    #
    [[ ${FUNCNAME[$i]} == $_test_fn ]]  && { echo "${FUNCNAME[$i]} is recursive" >&2; _rc=0; break; }
  done
  #
  return $_rc
}

function isSameFile  () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  # must be exactly 2 arguments
  (( $# != 2 ))  && return 1
  #
  return $(test $1 -ef $2)
}

function isSourced () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ "${FUNCNAME[1]}" == "source" ]]  && return 0
  return 1
}

function isTTY () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  return $(tty -s)
}

function isWritable () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  test -w "$1"
}

function isZeroLen () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  test -z "$1"
}

function json () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  jq "$@"  < /dev/stdin
  #
  return $?
}

function kernelModules () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _title="Linux Kernel Modules"
  #
  isOption noheading "$@"  && { dialog --title="$_title" -- "$(lsmod | tail -n +2 | sort)"; return 0; }
  #
  dialogShow --title="$_title" -- "$({ lsmod | head -1; }; { lsmod | tail -n +2 | sort; })"
  #
  return $?
}

function kit () {
  [[ "$1"       ]]  || { CMD=( "$FUNCNAME" "--help" ); "${CMD[@]}"; return  0; }
  # [[ "$1"                            ]]  || { "$FUNCNAME" --help; return  0; }
  # [[ "$2"                       ]]  || { eval set -- "$FUNCNAME" --help    ; }
  # [[ "$1"                            ]]  || { "$FUNCNAME" --help; return  0; }
  ### if no arguments, show help
  #
  cmdAlt            || { abortShow operationfailed "Error in cmdAlt()";        }
  # CMD=( "$(argAlt "$@")" )
  # CMD=( $(argAlt "$@") )
  # CMD="kit"; CMD=( $(argAlt "$CMD" "$@") )
  ### adjust args if an alternative command given
  ###   NOTE - Always Enclose Command Substitution In Double-quotes Inside Array Assignment
  #
  # [[ "${CMD[*]}" ]]  || { CMD[0]="kit"; }
  #
  # _ARGS="$*"; inspVar --func CMD[@]
  # declare -p CMD
  ### diagnostic
  #
  fnInit "${FUNCNAME}.20190911" "${CMD[@]}"  && {                    return 0; }
  # fnInit "${FUNCNAME}.20190206" "$@"  && {                           return 0; }
  # fnInit ${FUNCNAME} "$@" --revised "$_revised"  && {              return 0; }
  ### function initiation for --help, --version, etc.
  ###   NOTE
  ###     This line MUST execute AFTER the 'CMD=( $(argAlt "$@") )' line!
  #
  [[ "${CMD[0]}" != "kit"         ]]  && { "${CMD[@]}"            ; return $?; }
  # [[ "${CMD[0]}" != "kit"         ]]  && { ${CMD[0]} "${CMD[@]:1}"            ; return $?; }
  # [[ "${CMD[0]}" != "kit"         ]]  && { "${CMD[@]}"            ; return $?; }
  # [[ "${CMD[0]}" != "kit"         ]]  && { ${CMD[@]}            ; return $?; }
  ### run --alt CMD instead
  #
  isOption --help-all "$@"            && { helpAll                ; return  0; }
  ### pick from list of functions
  #
  isOption --note-all "$@"            && { noteAll                ; return  0; }
  ### pick from notes in METAFILE
  #
  return 0
}

function lineCount () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  # 3 techniques...
  #
  ( IFS=$'\n'; local -a _arr; _arr=($*); printf "%d\n" ${#_arr[@]} )
  ### count lines in array by docsalvager
  #
  # printf "%s\n" "$@" | awk 'END {print NR}'
  ### awk (by docsalvager)
  #
  # local -a _arr
  # readarray -t -n $_helplinessm  _arr  < <(printf "%s\n" "$_msg"); _lines=${#_arr[@]}
  ### per http://stackoverflow.com/a/23738288/470211
  ###   read only first $_helplinessm lines into array _arr and count # of array items
  #
  # printf "%s\n" "$_msg" | wc -l
  #
  return 0
}

function lineDelete () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local LINE=$1
  local FILE="$2"
  awk -v L=$LINE 'NR!=L {print $0}' "$FILE"
}

function lineInsert () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local LINE=$1
  local INS="$2"
  local FILE="$3"
  #
  awk -v L="$LINE" -v I="$INS" '
    NR == L {print I}
            {print $0}
    END {if (NR<L) {print I}}
  ' "$FILE"
}

function lineNumOf () {
  fnInit "$FUNCNAME.20180208" "$@"  && return 0
  #
  awk "/$1/ {print NR; exit}"
}

function lineNumbers () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  awk '{printf "%4d  %s\n",NR,$0}'
  # awk '{printf "%4d  %s\n",NR,$0}' <<< "$@"
  #
  return $?
}

function lineReplace () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local FIND="$1"
  local REPL="$2"
  local FILE="$3"
  #
  LINE=$(cat "$FILE" | lineNumOf "$FIND")
  cat "$FILE" | lineDelete $LINE | lineInsert $LINE "$REPL"
}

function linkMAXSYMLINKS () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _tmpdir="/tmp/kit/linksMAXSYMLINKS-$$"
  local _targ=0
  local _link=1
  #
  mkdir -p "$_tmpdir"               || { return 1; }
  cd       "$_tmpdir"               || { return 1; }
  touch symlink$_targ               || { return 1; }
  ln -s symlink$_targ symlink$_link || { return 1; }
  #
  while ! isLinkBroken ./symlink$_link
  do
    ((++_targ))
    ((++_link))
    ln -s symlink$_targ symlink$_link
  done
  #
  rm -r "$_tmpdir"
  #
  printf "$_targ"
  #
  return 0
}

function linkTarget () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _link="$1"
  local _targ=""
  local _rc=
  #
  # ARGS="$*"; inspVar ARGS _link _targ
  #
  [[ "$1"                      ]]   || { return 1; }
  ### Return false(1) when no path argument
  #
  isFileLink "$_link"               || { return 2; }
  ### Return false(2) when not a link
  #
  isLinkBroken "$_link"             && { printf "%s" "$(readlink -m "$_link")"; return 3; }
  ### Return false(3) when is a link that is broken
  #
  # isFileExists "$_link"             || { return 1; }
  ### Return false(1) when link does not exist
  ### (or is a link to an accessible file/dir)
  #
  _targ="$(readlink --canonicalize-existing "$_link")"   || { printf "%s" "$(readlink --canonicalize-missing "$_link")"; return 3; }
  # _targ="$(readlink -e "$_link")"   || { printf "%s" "$(readlink -m "$_link")"; return 3; }
  ### Print missing target and return false(3) when a broken link or other failure
  #
  printf "%s" "$_targ"
  return 0
  ### Print existing target and return true(0) since link is intact
}

function linkTrace () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _link="$1"
  local _namei="$(which namei)"
  local _pkg="$PACKAGES"
  local _targ=""
  local _rc=
  #
  [[ "$_namei" ]]  || {
    echo "
    kit.linkTrace() requires the 'namei' command which is not installed on this
    host ($HOST). A compatible installation package might be found in $_pkg
    on another host.
    "
    return 1
  }
  #
  exec 2>&1
  #
  $_namei --long --mountpoints "$_link"
  #
  return 0
}

function listClip () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  echo "${*/$1}"
}

function listIndex () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local WORD="$1"
  local LIST="$(echo ${@:2})"
  local ITEM=
  local i=
  #
  i=0
  for ITEM in $LIST
  do
    ((++i))
    [[ $ITEM == $WORD ]] && break
  done
  #
  [[ $ITEM == $WORD ]] && { echo $i; return 0; }
  [[ $ITEM == $WORD ]] || { echo  0; return 1; }
}

function log () {
  fnInit "${FUNCNAME}.20190826" "$@"  && return 0
  #
  # return
  #
  local _option="$1"; shift
  local _args="$*"
  local _fn="${FUNCNAME[1]}"
  local _logfile="$LOGFILE"
  local _at="$(inspFnStackItem 2)"
  local _now="$(timeDate)"
  local _msg=""
  local _prefix=""
  local _a=""
  local _pid=
  #
  _pid="$$"
  #
  _prefix="$(printf "%s [$HOST %05u]  %s" "$_now" "$_pid" "$_at")"
  # _prefix="$(printf "%s [p%05u]  %s" "$_now" "$_pid" "$_at")"
  #
  case $_option in
    --allerrors)
        exec 2>>"$_logfile";  return 0
        ;;
    --arguments)
        for _a in "$# argument(s)..." "$@"
        do
          _msg+="$_prefix:  ${_a}$NL"
        done
        #
        # _msg+="$_prefix:  $# argument(s)...$NL"
        # #
        # for _a
        # do
        #   _msg+=">  $_a$NL"
        # done
        ;;
    --start)
        _msg+="$NL$_prefix:  $_args  (start)$NL"
        ;;
    --status)
        _msg+="$_prefix:  $_args$NL"
        ;;
    --stop)
        _msg+="$_prefix:  $_args  (stop )$NL"
        ;;
    --system)
        command logger "$@"; return 0
        ;;
    *)
        abortShow optionbad "Unrecognized option:  $_option"
        ;;
  esac
  #
  # inspVar _option _args _fn _logfile _at _now _msg _prefix _a _pid
  #
  [[ "$_msg" ]]  && { printf "%b" "$_msg" >>"$_logfile"; }
  #
  return 0
}

function man () {
  fnInit "$FUNCNAME.20190923" "$@" && return 0
  # fnInit "$FUNCNAME.20190523" "$@" --help-text="(searches for manpages on $_host)" && return 0
  #
  local __=""
  local _apropos=""
  local _datetime="$(date '+%Y-%m-%d %H:%M:%S')"
  local _host="$HOST"
  local _logfile="$LOGDIR/gnome-terminal.log"
  local _man="/usr/bin/man"
  local _manhost="$MANHOST"
  local _msg=""
  local _page=""
  local _profile="Default"
  local _terminal="gnome-terminal"
  local _terminal_opts=""
  #
  [[ "$1"                          ]]     || { "$FUNCNAME" --help;                return 0; }
  ### no arguments so show --help
  #
  [[ "$1" =~ ^--                   ]]     || _page="$1"
  [[ "$_page"                      ]]     || _page="$(optionArg --page "$@")"
  ### if first arg is not '--page' assume is the --page argument
  #
  _failmsg="$(optionArg --failmsg "$@")"  || _failmsg="'$_page' not found"
  #
  [[ "$1" =~ -k|--apropos|--search ]]     && {
    _page="$2"
    _apropos="$($_man --apropos "$_page" 2>/dev/null)"                      || {              ### get matches
      _page="$(dialogEntry --text "$_failmsg" --label "Search for")"        || { return 1; }  ### no match so prompt
      _apropos="$($_man --apropos "$_page" 2>/dev/null)"                    || { return 1; }  ### get new matches
    }
    #
    _page="$(dialogSelect --title "man --appropos $_page" -- "$_apropos")"  || { return 1; }  ### list matches
    #
    _page="$(echo "$_page" | cut --delimiter=$' ' --fields=1)"
  }
  ### --search
  #
  _terminal_opts="--title $_page --display :0 --profile $_profile"
  # _terminal_opts="--display :0 --title $_host:$_page --profile $_profile"
  # _terminal_opts="--display :0 --title $_host: $FUNCNAME --profile $_profile"
  ### set terminal options (assumes gnome-terminal)
  #
  # echo "$_terminal $_terminal_opts"
  #
  # _ARGS="$*"; inspVar --func
  #
  echo "$_datetime Starting $_terminal ..."  >$_logfile
  #
  __="$($_man "$_page" 2>&1)"  || { man --search "$_page" --failmsg "$__"   ; return $?; }
  #
  $_terminal $_terminal_opts -- $_man "$_page"  2>$_logfile
  ### display manpage in a dialog window
  ###   lookup on known manpage host if necessary
  #
  return $?
}

function manifest () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _script="$1"
  local _homedir="$HOMEDIR"
  local _file="${_homedir}/${_script}.manifest"
  local _manifest=""
  local _msg=""
  #
  _manifest="$(fileOpen "$_file")"  || { errorShow filenotfound "$_file"; return 1; }
  #
  _msg+="VAR   HOMEDIR=\"$HOMEDIR\"$NL"
  _msg+="FILE  \"$_script\"$NL"
  _msg+="FILE  \"$_manifest\"$NL"
  _msg+="FILE  \"$_verify\"$NL"
  #
  printf "%s" "$_msg" >>"$_manifest"
  #
  return 0
}

function manifestVerify () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _script="$1"
  local _homedir="$HOMEDIR"
  local _manifest="$HOMEDIR/${_script}.manifest"
  local -a _list=( echo "$(cat $_manifest)" )
  local _i=""
  #
  _manifest="$(fileOpen "$_manifest")"
  #
  for _i in $_list
  do
    _l="${_list}"         ### TODO:  first field of $_l string
    case _l in
      VAR)
        [[ "$_i"  ]]  || { errorShow argumentnotfound "Variable ($_i) is empty."; }
        ;;
      FILE)
        [[ -e $_l ]]  || { errorShow filenotfound "$_i"; }
        return 1
        ;;
      *)
        errorShow option "Unrecognized manifest item type:  $_i"
        return 1
        ;;
    esac
  done
  #
  return 0
}

function memory () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _pid="$$"
  local _msg=""
  local _argmax="$(getconf ARG_MAX)"
  local _getconf="$((_argmax / 1024))"
  local _status="/proc/$_pid/status"
  #
  printf "%s$NL" "Memory limits for process $_pid ..."
  _msg+="$(printf "Maximum Limit (%-28s):  %8d kB" "\$(getconf ARG_MAX)/1024" "$_getconf")$NL"
  _msg+="$(printf "Current Use   (%-28s):  %11s"   "$_status VmData"          "$(grep 'VmData:' "$_status" | awk '{print $2,$3}')")$NL"
  _msg+="-------------$NL"
  _msg+="$(exec xargs --show-limits </dev/null 2>&1)"
  #
  printAt 2 "$_msg"
}

function memoryShow () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  # EXPERIMENTAL
  # local _pid="${1:-$PPID}]"
  ### report memory use of pid passed in argument one
  ### if no arguments, use parent process ID
  #
  dialog --title="Memory Use of process (memoryShow)" -- "$(memory)"
  # dialogShow --title="Memory Use of process (memoryShow)" -- "$(memory "$_pid")"
  # dialogShow --title="Memory Use of process (memoryShow)" -- "$(memory "$@")"
}

function meta () {
  fnInit "$FUNCNAME.20190908" "$@"  && return 0
  #
  # [[ "$1" ]]  || { "$FUNCNAME" --help; return 0; }
  ### if no arguments, show --help
  #
  local __=""
  local _errmsg="Either a known subject or a search string is required"
  local _meta=""
  local _metafile="$METAFILE"
  local _search=""
  local _subject=""
  local _subjectvar=""
  local _title=""
  #
  [[ "$1" =~ ^--  ]]  || _subject="$1"
  [[ "$_subject"  ]]  || _subject="$(optionArg --subject "$@")"
  ### if first arg is not '--subject' assume is the --subject argument
  #
  [[ "$_subject"  ]]  || { _subject="$(dialogEntry --title="$SCRIPT" --label="Topic" --text="Search documentation for topic" --yadopts center)"  || exit 1; }
  ### prompt for KEY word if no arguments supplied

  _title="$(optionArg --title "${@:2}")"  || { _title="$TITLE:  $_subject"; }
  # _title="$(optionArg --title "${@:2}")"  || { _title="$TITLE:  $@"; }
  # _title="$(optionArg --title "${@:2}")"  || { _title="$TITLE:  $_subject"; }
  #
  # _search="$(optionArg --search "$@")"; [[ "$_search" ]]  || { _search="*"; }
  #
  _search="$(optionArg --search "$@")"  && {
    [[ "$_search" ]]  || { _search="$_subject"; }
    #
    __="$(dialogSelect --width 600 --title "Meta --search" --separator "" --column "Subject" --text "Select topic for more help" -- "$(
        awk -v S="$_search" '
          /^[[:alnum:]_]*="$/ {
            v = gensub(/^([[:alnum:]_]*)="/, "\\1", "1"); if (S == "" || v ~ S)  { print v }
          }
        ' $_metafile | sort -u
      )" || { return $?; }
    )"
    ### get list of metafile help subjects containing _search string
    #
    _subject="${__%|}"
    #
    [[ "$_subject"   ]]  || {                                        return 1; }
    ### only continue if a subject was selected
  }
  [[ "$_subject"     ]]  || { abortShow argumentnotfound "$_errmsg"; return 1; }
  # isAnOption "$_subject"                && { abortShow unexpectedoption "$_errmsg"; return 1; }
  ### subject (usually a command/function) MUST be first argument
  ### if instead it is an option, abort
  #
  _subjectvar="${_subject//-/_}"
  ### _metafile subjects are variables which cannot have hyphens so convert to underscores
  #
  _subjectvar="${_subject//\//_}"
  ### _metafile subjects are variables which cannot have forward-slashes so convert to underscores
  ###   this allows _metafile to document files like /etc/fstab (_etc_fstab)
  #
  _meta="$(metaSource "$_subjectvar" "${@:2}")"
  ### metaSource returns true(0) if _subjectvar was found.
  ### In some cases, the metadata will have already been printed/shown and _meta will be null.
  #
  # _ARGS="$*"; inspVar --func
  #
  if [[ "$_meta" ]]
  then
    if [[ "${_subjectvar##*__}" == "macro" ]]
    then
      eval $_meta                                                     ; return 0
      ### invoke a 'macro'
    else
      dialog --middle --title "$_title" --stdin --more "kit man --search $_subject" -- "$_meta$NL$NL"
      ### show information
      ###   --more uses the original _subject for man
      #
      return 0
    fi
  fi
  ### If $_meta if non-null, eval if a macro. Otherwise, send it to dialog()
  #
  return 1
  ### nothing to eval or print
}

function metaFiles () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _dir=""
  local _file=""
  #
  [[ "$1"           ]]  || { "$FUNCNAME" --help; return 0; }
  ### no arguments so show --help
  #
  _dir="$1/.meta"
  #
  isDirExists "${_dir}"                      || {                    return 1; }
  #
  _file="$(fileSelectShow "$_dir")"          && { fileShow "$_file"; return 0; }
  #
  return 1
}

function metaFind () {
  fnInit "$FUNCNAME.20190826" "$@"  && return 0
  #
  local _key=""
  local _cmd=""                         ### strip off _help suffix if present
  local _var=""                         ### hyphens illegal in variable names
  local _cmdtype=""                     ### alias|keyword|function|builtin|file|""
  local _error=                         ### error code ($?) of last command
  local _msg=""                         ### output text
  local _text=""                        ### output text
  #
  _key="$1"                             ### key word to search for
  _cmd="${_key%_help}"                  ### strip off _help suffix if present
  _var="${_key//-/_}"                   ### hyphens illegal in variable names
  ### initialize
  #
  [[ "$_key"                        ]]  || { "$FUNCNAME" --help    ; return 0; }
  ### no arguments so show --help
  #
  _cmdtype="$(cmdType $_cmd)"
  ### command type determines how to find help
  #
  # _ARGS="$*"; inspVar --func CMD[@]
  ### diagnostics
  #
  case "$_cmdtype" in
    function)
      #
      _text+="$( note "$_var" "${@:2}" )"  ; { printf "%s\n" "$_text"; return 0; }
      ### note() concatenates any or all of the options (in order)...
      ###   --before="..."
      ###   --help-text="..."
      ###   --metafile="..."
      ###   --after="..."
      #
      # CMD=( "$_cmd" "${@:2}" ); ${CMD[@]}                           ; return 0
      # CMD=( "$_cmd" "${@:2}" ); $_cmd --help "${@:2}"               ; return 0
      ### 20190330 ABANDONED
      ### 20190513 ABANDONED AGAIN
      ###   Using '$_cmd --help ...' instead of calling 'note' causes dialog()
      ###   to run 'yad' in foreground instead of background so subsequent processing
      ###   (like --inspect) not done till 'yad' button clicked
      ;;
    file)
      _text="$(note "$_var" "${@:2}")"                  && { printf "%s\n" "$_text" ; return 0; }
      ### if found in metafile, use it and be done
      ###   (thus capture of cmd --help text must be done within the metafile entry)
      #
      # CMD=( "$_cmd" "${@:2}" )                           ;   $_cmd --help  2>&1     ; return $?
      # CMD=( "$_cmd" "${@:2}" )                           ;   $_cmd --help           ; return $?
      ### WHY DID I DO THIS INSTEAD OF THE text= BELOW?
      #
      _text="$($_cmd --help  2>&1)"; [[ "$_text" ]]     || { _text="$($_cmd -h 2>&1)"; }
      [[ "$_text" ]]                                    && { printf "%s$NL" "$_text"; return 0; }
      ### print external command help text, if any and return success
      ###   The return code of '$_cmd --help' is unreliable so the usual tests are unavailable.
      ###     Some cmds treat help as failure and return false while some return true.
      ###     Some cmds may print an error message on stderr while some print on stdout.
      #
      printf "%s$NL" "No kit or command --help found. Check Help button below for manpage."
      return 1
      ;;
    keyword|builtin)
      _text+="$(note "$_var" "${@:2}")"; [[ "$_text" ]]  && { printf "%s\n" "$_text"; return 0; }
      ### if there is a note, use it instead
      #
      _text+="$(help  $_cmd  2>&1)"                       ; { printf "%s\n" "$_text"; return 0; }
      ### otherwise, use bash command or keyword help
      ;;
    *)
      _text+="$(note "$_var" "${@:2}")"                  && { printf "%s\n" "$_text"; return 0; }
      ### look for a non-function note in the METAFILE
      #
      command kit man --search "$_key"                   && {                         return 0; }
      ### look for a non-command manpage ('command kit ...' launches another process
      ### instead of calling the kit() function within this process which would error
      #
      return 1
      ### nothing found
      ;;
  esac
}

function metaSource () {
  fnInit "$FUNCNAME.20190728" "$@"  && return 0
  #
  local _cmd="$1"
  local _source=""
  local _protocal=""
  local _msg=""
  local _err=
  #
  # ARGS="$*"; inspVar --func
  #
  [[ "$_cmd"       ]]  || { "$FUNCNAME" --help; return 0; }
  ### no arguments so show --help
  #
  _source="$(  optionArg --source   "${@:2}")"
  #
  _protocal="$(optionArg --protocal "${@:2}")"
  #
  if [[ "$_source" ]]
  then
    _msg="$(${_protocal:-ssh} $_source $_cmd --help  2>&1)"  && {
      printf  "From %s ...$NL" "$_source"
      printAt 2 "$_msg"
      return 0
    }
    ### no protocal so default to ssh
    #
    return 1
  else
    _msg="$(metaFind "$_cmd" "${@:2}")"  && {
    # _msg="$(metaFind "$@")"  && {
    # _msg="$(metaFind "$_cmd" "${@:2}"  || { echo "'$_cmd' not found"; })"  && {
      printf "%s$NL" "$_msg"
      return 0
    }
    ### No source (thus, no protocal either?) so do local search with metaFind().
    ### metaFind returns true(0) if there is metadata (help, notes, etc.).
    ### In some cases, the metadata will have already been printed/shown and _msg will be null.
    #
    return 1
  fi
}

function names () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _pfx=""
  local _type=""
  #
  _type="$(optionArg --type "$@")"  || { return 1; }
  #
  _pfx="$( optionArg --pfx  "$@")"
  #
  # ARGS="$*"; inspVar ARGS _type _pfx
  #
  compgen -A "$_type" "$_pfx"
  ### list available objects of given type, optionally those starting with $_pfx
  #
  return ${PIPESTATUS[0]}
  ### return status of the compgen
}

function note () {
  fnInit "$FUNCNAME.20200426" "$@" && return 0
  #
  ###
  ### 20180407  BUG - Inline help (--help-text="...") is not being returned
  ###   Function assumes --before, --after, --help-text, etc. are passed as
  ###   parameters, but metaFind (& others?) do not have --help-text, etc. to pass.
  ###
  #
  local _aliasOf=""
  local _aliasOf_before=""
  local _code=""
  local _help=""
  local _item=""
  local _metafile=""
  local _note=""
  local _revised=""
  local _reAliasOf=""
  local _reRevised=""
  local _text=""
  local _tmpfile=""
  local _val=""
  #
  _note="$1"
  _reAliasOf="aliasOf (\b.*\b)"
  _reRevised="fnInit [\"]?[$][\{]?FUNCNAME[\}]?[.]([0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9])[\"]?"
  _tmpfile="$TMPDIR/$FUNCNAME-$$"
  #
  >"$_tmpfile"
  ### clear temporary buffer
  #
  _metafile="$(optionArg --metafile "${@:2}")"                   || { _metafile="$METAFILE"; }
  #
  _code="$(declare -f "$_note")"
  ### get function definition so can extract --help-text
  ###   in some cases, --help-text cannot not be passed in arguments
  ###   such as when called on commandline like...
  ###     choraleHistory-000 --help
  #
  [[ "$_code" =~ $_reAliasOf ]]  && {
    _aliasOf="${BASH_REMATCH[1]}"
    _aliasOf_before="[ $_note is an alias of $_aliasOf ]$NL"; printf "%s$NL" "$_aliasOf_before" >>"$_tmpfile";
    _code="$(declare -f $_aliasOf)"
  }
  ### if function is an alias, grab the alias code instead
  #
  [[ "$_code" =~ $_reRevised ]]  && { _revised="${BASH_REMATCH[1]}"; }
  ### revision date now dot-suffixed to first argument of fnInit
  ### which contains parent FUNCNAME as in FUNCNAME.YYYYMMDD
  ###   replaces --revised ...
  #
  # _ARGS="$*"; inspVar --func
  #
  _item="$(optionArg --before    "${@:2}")"                      && { printf "%s$NL" "$_item" >>"$_tmpfile"; }
  ### prepend --before text
  #
  if _item="$(optionArg --help-text "${@:2}")"
  then
    printf "%s$NL" "$_item" >>"$_tmpfile"
  else
    # _code="$(declare -f "$_note")"
    # ### get function definition so can extract --help-text
    # ###   in some cases, --help-text cannot not be passed in arguments
    # ###   such as when called on commandline like...
    # ###     choraleHistory-000 --help
    # #
    isIn "--help-text" "$_code"  && {
      _item="${_code#*--help-text=\"}"
      ### trim off text before help text
      #
      _item="${_item%%${NL}\"*}"
      ### trim off text after help text
      #
      source <(echo "_help=\"$_item\"")
      ### Effectively, 'source' the contents of _item allowing $(command --help)
      ### output to be embedded in help text.
      ###   WARNING -- SECURITY ISSUE
      ###     Code may be embedded in $kit_META items. In this example, the
      ###     normal yad help is returned, followed by notes and/or links in the
      ###     $kit_META.
      ###     Example:
      ###       yad_help="$(yad --help)
      ###           Additional notes and links to online resources ..."
      #
      _item="$(printDecoded "$_help")"
      # _item="${_help//\\\"/\"}"
      # _item="${_help//\\\\/\\}"
      ### unescape escaped characters
      ### 20200426 replaced with printDecoded()
      #
      printf "%s$NL" "$_item" >>"$_tmpfile"
      ### append to output
      #
      # inspVar --func
    }
  fi
  ### prepend inline --help-text
  #
  # _ARGS="$*"; inspVar --func
  #
  [[ "$_aliasOf" ]]  && { _note="$_aliasOf"; }
  ### if aliased, have noteFind get meta data for the alias
  #
  _item="$(noteFind "$_note" "${@:2}" --metafile "$_metafile")"  && { printf "%s$NL" "$_item" >>"$_tmpfile"; }
  ### noteFind only returns true(0) if there is something to print
  ### if false(1), then there are no notes and no error messages
  #
  _item="$(optionArg --after     "${@:2}")"                      && { printf "%s$NL" "$_item" >>"$_tmpfile"; }
  ### append --after text
  #
  isFnLoaded "${_note%_help}" >/dev/null                         && { printf "%s$NL" "$HELPCOMMON" >>"$_tmpfile"; }
  ### append common help if this is a loaded kit function
  ### (note name will be functionName_help so strip the '_help' suffix off)
  #
  # _ARGS="$*"; inspVar --func CMD CMD[@]
  #
  isFileNonNull "$_tmpfile"                                      && { cat "$_tmpfile"; rm "$_tmpfile"; return 0; }
  ### return true(0) if there is text to print
  #
  # isFileExists "$_tmpfile"  && rm "$_tmpfile"                   <<<< TEMPORARILY COMMENT OUT 20190728
  #
  return 1
}

function noteAll () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _pfx=""
  local _file=""
  local _metafile=""
  #
  _pfx="$(     optionArg --pfx  "$@")"
  _metafile="$(optionArg --metafile "$@")"
  _metafile="${_metafile:-$METAFILE}"; [[ "$_metafile" ]]  || { return 1; }
  ### requires default meta file if not supplied
  #
  # Pick List
  yad --list --center --geometry=200x500 --separator=" "        \
      --title="$CMD"                                            \
      --text="  Double-click for note ..."                      \
      --column=TOPIC                                            \
      --button=gtk-cancel:1 --button=gtk-ok:0                   \
      --print-column=1                                          \
      --dclick-action="meta "                                   \
      $(noteList --pfx "$_pfx" --metafile="$_metafile")         & ### in background
  #   $(UI=CLI; noteList --pfx "$_pfx" --metafile="$_metafile") & ### in background
  #
  return 0
}

function noteFind () {
  fnInit "$FUNCNAME.20180208" "$@"  && return 0
  #
  local _metafile=""
  local _note=""
  local _val=""
  local _var="$1"
  #
  _metafile="$(optionArg --metafile "$@")"
  _metafile="${_metafile:-$METAFILE}"
  [[ "$_metafile" ]]  || { abortShow filenotfound "No --metafile=FILE option and \$METAFILE not yet set"; }
  ### a metafile is required
  #
  #
  [[ "$_var" =~ ^[[:digit:]] ]]  && {
    errorShow optionbad "First character of note name must be alpha or underscore. Try prefixing the command with '_'."
  }
  #
  _val="$(varFind "${_var}_help" --metafile "$_metafile")"  ||
    _val="$(varFind "${_var}"    --metafile "$_metafile")"  || { return 1; }
  ### get the VALUE of the variable from _metafile
  #
  source <(echo "_note=\"$_val\"")
  ### Effectively, 'source' the contents of _note allowing $(command --help)
  ### output to be embedded in help text.
  ### Must do here to include kit_common_help as well as in note() for other things?
  ###
  ###   WARNING -- SECURITY ISSUE
  ###     Code may be embedded in $kit_META items. In this example, the
  ###     normal yad help is returned, followed by notes and/or links in the
  ###     $kit_META.
  ###     Example:
  ###       yad_help="$(yad --help)
  ###           Additional notes and links to online resources ..."
  #
  # _ARGS="$*"; inspVar --func
  #
  [[ "$_note"   ]]  && { printf "%s\n" "$_note"; return 0; }
  ### print the VALUE of the variable if anything to print
  #
  return 1
}

function noteList ()  {                                     ### Revised 20180125
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _pfx=""
  local _metafile=""
  local _regex=""
  #
  # inspVarShow _pfx _metafile _regex
  #
  _pfx="$(     optionArg pfx      "$@")"
  _metafile="$(optionArg metafile "$@")"
  _metafile="${_metafile:-$METAFILE}"; [[ "$_metafile" ]]  || { return 1; }
  ### requires default meta file if not supplied
  #
  _regex="^${_pfx}[_[:alnum:]]*="
  ### search for
  #
  grep --extended-regexp --only-matching "$_regex" "$_metafile" | tr -d '='
  #
  return ${PIPESTATUS[0]}
  ### return result of the grep
}

function noteShow () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _note="$1"
  local _msg=""
  local _title=""
  #
  _title="$(optionArg --title "$@")"   || { _title="$TITLE:  $_note"; }
  # _title="$(optionArg title "$@")" || { _title="$TITLE"; }
  #
  _msg="$(note "$@")"
  #
  #
  # _ARGS="$*"; inspVar --func
  #
  #
  [[ "$_msg" ]]  && { dialog --middle --title="$_title" -- "$_msg$NL$NL"; return 0; }
  ### show note or error message from noteFind()
  #
  return 1
}

function option () {
  fnInit "$FUNCNAME.20190513" "$@"     && return 0
  #
  local __=""
  local _find="$1"
  #
  __="$(optionArg "$@")"               && { printf "%s$NL" "$_find"; return 0; }
  # optionArg "$@" >/dev/null  && { printf "%s$NL" "$_find"; return 0; }
  # optionArg "$@"  && { printf "%s$NL" "$_find"; return 0; }
  ### use optionArg to determine if option was given,
  ### but print the option instead of its arguments if true(0)
  #
  return 1
}

function optionArg () {
  fnInit "${FUNCNAME}.20190502" "$@"  && return 0
  #
  local _a=""                 ### current commandline argument
  local _allpos=""            ### all arguments are positional (boolean)
  local _arc=                 ### argument return code  (boolean)
  local _argn=""              ### optional arg number of first option's arguments (--option:2, --option:3, ...)
  local _find=""              ### option to search for
  local _oan=                 ### current option argument number
  local _orc=                 ### option return code  (boolean)
  local _re_position='^[1-9][0-9]*$' ### regex to validate optional argument number to find
  #
  local -a _optargs           ### array of just the arguments to given option
  #
  (( $# < 2               ))  && {                                   return 1; }
  ### 1 argument: no match possible
  #
  _find="${1%%:*}"
  # _find="$1"; shift
  ### first argument always taken to be the option to find
  ###   ex:  _helptext="$(optionArg --help-text "$@")"
  #
  _argn="$( _argn="${1#*:}"; [[ "$_argn" != "$_find" ]] && echo "$_argn" )"
  ### optional argument number suffix (--option:1)
  #
  shift
  ### discard first argument to simplify subsequent processing
  #
  [[ "$_argn" =~ $_re_position ]]  || { _argn=""; }
  ### ignore argument number if invalid
  ### do not report as that creates an circular reference that hangs
  #
  [[ "$_find" != "--" ]]  && [[ ! ("$_find" =~ ^--[^-]) ]]  && { _find="--$_find"; }
  ### allowable syntax for _find ONLY (e.g. first argument):
  ###   --              find positional arguments and print each subsequent arg up to next --option
  ###   --aaa | aaa     find option --aaa and print each subsequent arg up to next --option
  #
  [[ "$*" =~ --       ]]  || { _allpos="--"; }
  ### if no hyphens at all, treat all arguments as positional
  #
  _oan=1
  _orc=1
  _arc=1
  for _a in $_allpos "$@"
  do
    # printf "_a= '%s'\n" "$_a"  >&2
    ### diagnostics
    ###
    ### $1 has been removed from $@ list, leaving just the arguments to search
    ###
    [[ "$_a" == "$_find"   ]]  && { _orc=0                            ; continue; }
    ### if _a is the option we want (w/o =), set _orc true(0) and get next argument
    #
    [[ "$_a" =~ ^${_find}= ]]  && { _orc=0; _optargs[0]="${_a#${_find}=}"; break; }
    # [[ "$_a" =~ ^${_find}= ]]  && { _orc=0; _optargs="${_a#${_find}=}"; break; }
    ### _a is an --option=argument pair (_a begins with --option=)
    ###   so return remainder of string as the ONE AND ONLY option argument
    #
    (( $_orc != 0          ))  && {                                     continue; }
    ### option has not been found so get next argument
    ### NOTE that ((...)) is reverse logic...
    ###   (( 1 )) is true (all non-zero actually)
    ###   (( 0 )) is false
    ###   but comparison return codes are same logic as [[...]]
    #
    # option has been found...
    #
    # echo "$_find _optargs:  $_optargs"  >&2
    ### diagnostics
    #
    [[ "$_a" =~ ^--        ]]  && {                                        break; }
    ### _a is next --option so stop here with BREAK
    #
    [[ "$_argn"            ]]  || { _optargs+=( "${_a}" );((++_oan))  ; continue; }
    #- [[ "$_argn"            ]]  || { _optargs+="${_a}";((++_oan)); continue; }
    #+ [[ "$_argn"            ]]  || { _optargs+="${_a}${NL}";((++_oan)); continue; }
    # [[ "$_argn"            ]]  || { _optargs+="${_a} ";((++_oan)); continue; }
    ### not an option so add _a$NL to list of option arguments and get next argument
    #
    # if we make it here then we are looking for a specific option argument
    #
    (( _oan    == _argn      ))  && { unset _optargs; _optargs=( "$_a"); _arc=0; break; }
    ### is the option argument number requested so return just that argument
    #
    ((++_oan));
    ### increment option argument number
  done
  ### parse arguments
  ### _orc is true(0) if option found whether or not an --option argument is printed
  ### _arc is only true(0) if _orc is true AND the specified --option argument was found
  #
  (( (_argn > 0) && (_arc > 0) ))  && _orc=1
  # [[ "$_argn" ]] && (( _orc == 0 )) && (( _arc != 0 ))  && _orc=1
  #
  # echo "${_optargs[@]}"  >&2
  # echo "${#_optargs[@]}"  >&2
  ### diagnostics
  #
  printf "%s$NL" "${_optargs[@]}"
  # echo "${_optargs[@]}"
  # printf "%s" "${_optargs[@]}"
  # printf "%s" "$(varTrim "$_optargs")"
  # echo "$(varTrim "$_optargs")"
  # echo "$_optargs"
  # printf "%s" "$_optargs"
  #
  return $_orc
}

function optionName () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _opt=
  #
  _opt="${1/*-/}"
  ### strip off any number of leading hyphens
  #
  _opt="${_opt%%=*}"
  ### strip off any following argument
}

### NONFUNCTIONAL
###   Causes "unexpected EOF looking for matching `''" in bash 3 but not bash 4
###   Use pathStr instead
#
# function pathName () {                                      ### Revised 20180204
#   fnInit ${FUNCNAME} "$@"  && return 0
#   #
#   local _cwdL=""
#   local _file=""
#   local _path=""
#   local _rela=""
#   local _type=""
#   #
#   [[ "$1" =~ ^-- ]]  || { _rela="$1"; }
#   [[ "$_rela"    ]]  || { _rela="$(optionArg --logical  "$@")"  && _type="-L"; }
#   [[ "$_rela"    ]]  || { _rela="$(optionArg --physical "$@")"  && _type="-P"; }
#   #
#   [[ "$_type" && (! "$_rela") ]]  && { _rela="."                             ; }
#   ### default to current directory if a valid option supplied but no _rela
#   #
#   [[ "$_rela"    ]]  || { "$FUNCNAME" --help                       ; return 0; }
#   ### give up
#   #
#   _cwdL="$(pwd -L)"
#   #
#   _path="$(
#     cd $_rela 2>/dev/null  || {
#       _file="${_rela##*/}"; _file="${_rela/$_file/}"                      ###<<< DOESN'T WORK
#       # _file="${_rela##*/}"; [[ "$_file" == "$_rela" ]]  && _file=""
#       _rela="${_rela%/*}"
#       cd $_rela 2>/dev/null
#     }
#     ### position to appropriate directory
#     #
#     printf "%s" "$(pwd $_type)${_file:+/$_file}"
#     #
#     echo "$(cd "$(dirname "$_rela")"; pwd)/$(basename "$_rela")"
#   )"
#   #
#   _ARGS="$*"; inspVar --func HOST HOMEDIR "${!_@}"
#   #
#   echo "$_path"; return 0
# }

function pathRelativePy () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _msg=""
  local _pycode='import os.path, sys; print os.path.relpath(sys.argv[1],sys.argv[2])'
  local _pyerror=""
  #
  _msg="$(python --version 2>&1)"                       || { printf "%s$NL" "$_msg"; return 1; }
  #
  _pyerror="$_msg does not support required functionality..."
  # _pyerror="$(python --version 2>&1) does not support required functionality..."
  #
  _msg="$(python -c "$_pycode" "$1" "${2-$PWD}" 2>&1)"  && { printf "%s$NL" "$_msg"; return 0; }
  # python -c "$_pycode" "$1" "${2-$PWD}"  || { return 0; }
  #
  printf "$_pyerror$NL%s$NL" "$(printAt 2 "$_msg")"
  return 1
}

function  pathStr () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _option=""
  local _str=""
  local _cwd=""
  local _path=""
  local _dir=""
  local _file=""
  local _ext=""
  ### declaration
  #
  local _option="$1"
  local _str="$2"
  local _cwd="$(pwd)"
  ### initialization
  #
  # inspVar _option _str _cwd
  #
  # validate there are 2 args and first is an --option
  [[ $(argsNumber "$@") != 2 ]]         && return 1
  ! isAnOption "$@"                     && return 1
  #
  _path="$(pathStrAbsolute "$_str")"
  ### resolve any relative logical parent directory(s)
  #
  _dir="${_path%/*}"
  _file="${_path##*/}"
  _base="${_file%.*}"; [[ "$_base" == "" ]]  && { _base="$_file"; }
  ### if _file is a dotfile with no extension, _base is whole _file name
  #
  [[ "$_file" =~ [.] ]]  && {
    _ext="${_file##*.}"
    ### isolate any extension
    #
    [[ "$_ext"  == "$_file" ]]  && _ext=""
    ### _file has no extension
    #
    [[ ".$_ext" == "$_file" ]]  && _ext=""
    ### _file is a dotfile with no extension
  }
  #
  case "$_option" in
   --path)  echo "$_path"; return 0;;
    --dir)  echo "$_dir" ; return 0;;
   --file)  echo "$_file"; return 0;;
   --base)  echo "$_base"; return 0;;
    --ext)  echo "$_ext" ; return 0;;
  esac
  #
  return 1
}

function pathStrAbsolute () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _str="$*"
  local _cwd="$(pwd -L)"
  local _pcwd="$(cd ..; pwd -L)"
  local _path
  local _pfx
  local _pfx1
  local _pfx2
  local _pfx3
  local _pfx4
  local _pfx5
  local _sfx
  #
  # printf "\npathStrAbsolute input:  %s" "$_str" >&2;
  # printf "\n parent of parent dir:  %s" "$_pcwd" >&2;
  #
  _path=""
  #
  [[ "${_str:0:1}" == "/"   ]]  && _path="$_str"
  ### given path is absolute (but may contain relative elements)
  #
  [[ "${_str:0:2}" == "./"  ]]  && _path="$_cwd/${_str:2}"
  ### given path is in current directory
  #
  [[ "${_str}"     == ".."  ]]  && _path="$_pcwd/"
  ### given path is the parent of the current directory
  #
  [[ "${_str:0:3}" == "../" ]]  && _path="$_pcwd/${_str:3}"
  ### given path is in parent of the current directory
  #
  [[ "$_path"      == ""    ]]  && _path="$_cwd/$_str"
  ### given path is none of the above so must be in current directory
  #
  # inspVar _str _path _cwd _pcwd
  # printf "\n%s\n\n" "_str=$_str   (start)_path=$_path"
  #
  _sfx="${_path##*../}"
  _pfx1="${_path%$_sfx}"
  _pfx2="${_pfx1%/*/../}"
  _pfx3="${_pfx2/%*\/..\//}"
  _pfx4="${_pfx3/%\/..\//}"
  _pfx5="${_pfx4/%..\//}"
  [[ "${_sfx:0:1}" == "/" ]]  && _path="${_pfx5}${_sfx}"
  [[ "${_sfx:0:1}" != "/" ]]  && _path="${_pfx5}/${_sfx}"
  ### resolve relative parent directory(s)
  #
  # local _par="${_path%/*}"; _par="${_par:-/}"
  # local _gpar="${_par%/*}"
  # local _ggpar="${_gpar%/*}"
  # local _gggpar="${_ggpar%/*}"
  # printf "\n%s\n\n" "_pfx1=$_pfx1   _pfx2=$_pfx2   _pfx3=$_pfx3   _pfx4=$_pfx4   _pfx5=$_pfx5   _sfx=$_sfx"
  # printf "\n%s\n\n" "_gggpar=$_gggpar   _ggpar=$_ggpar   _gpar=$_gpar   _par=$_par   _path=$_path"
  #
  printf "%s" "$_path"
  #
  return 0
}

function pathStrTest () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  printf "\n"
  printf "%s\n" "pathStr() test for:  $1 ..."
  printf "%s\n" "  file= $(pathStr --file $1)"
  printf "%s\n" "   dir= $(pathStr --dir  $1)"
  printf "%s\n" "  base= $(pathStr --base $1)"
  printf "%s\n" "   ext= $(pathStr --ext  $1)"
  printf "%s\n" "  path= $(pathStr --path $1)"
}

function pathStrTestSuite () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  pathStrTest "/a/b"
  pathStrTest "a/.b"
  pathStrTest "/e/a/.b.00.d"
  pathStrTest "./"
  pathStrTest "./b"
  pathStrTest "../b"
  pathStrTest ".b"
  pathStrTest ".b.00"
  pathStrTest ".b.00.d"
  pathStrTest "b"
  pathStrTest "e/a/b"
  pathStrTest "e/a/b.c"
  pathStrTest "e/a/b.c.d"
  pathStrTest "e/a/.b"
  pathStrTest "e/a/.b.c"
  pathStrTest "e/a/.b.c.d"
  pathStrTest "e/a/.b.00.d"
  pathStrTest "."
  return
}

function permSetuid () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _msg=""
  #
  dialog --title="SETUID Files" -- "$( ls -ld $(find /  -ignore_readdir_race -perm /6000 -type f -print) )"
  #
  return 0
}

function pipeClose () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _pipe="$1"
  #
  isPipeExists "$_pipe"  || { abortShow filenotfound  "Pipe ($_pipe) not found"; }
  #
  rm --force "$_pipe"
  #
  return $?
}

function pipeOpen () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _pipename="$1"
  local _pipedir=""
  local _pipepath=""
  # local _fd=0
  #
  _pipedir="$( pathStr --dir  "$_pipename")"
  #### directory containing pipe
  #
  _pipepath="$(pathStr --path "$_pipename")"
  #### full, absolute path to pipe
  #
  # _args="$*"; inspVarShow _args _pipename _pipedir _pipepath
  #
  isPipeExists "$_pipepath"    && { printf "%s\n" "$_pipepath"; return 0; }
  ### file already exists so return success
  #
  mkdir --parents "$_pipedir"  || { abortShow operationfailed "Unable to create directory: ${_pipedir}$NL$NL( details in log file:  ${LOGFILE}... )"; }
  ### create directory (and any parents required) using argument as given
  #
  mkfifo "$_pipepath"          || { abortShow operationfailed "Unable to create named pipe: ${_pipepath}$NL$NL( details in log file:  ${LOGFILE}... )"; }
  ### create named pipe (FIFO buffer "file")
  #
  # exec {_fd}>$_pipepath
  ### attach the first unused file descriptor greater than 10, bidirectionally, to the pipe
  ### Not needed??? 20160621
  ###   See bash manpage /^REDIRECTION for syntax
  #
  printf "%s\n" "$_pipepath"
  # printf "%d" $_fd
  #
  return 0
}

function printAt () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _at=
  local _msg=""
  local _re='^[0-9]+$'
  #
  # echo "printAt ARGS: $*" >&2
  #
  _at="${1:- 0}"; shift
  #
  [[ "$_at" =~ $_re ]]  || { errorShow operationfailed "First argument must be the column number"; return 1; }
  ### error if _at not a number
  #
  awk -v AT=$_at '
    ! length { printf "\n"               }
      length { printf "%*s%s\n",AT,"",$0 }
  ' <<< "$@"
  ### print arguments indented if any
  #
  return 0
}

function printControl () {
  fnInit "$FUNCNAME.20200427" "$@"  && return 0
  #
  local __=""
  local _before=""
  local _line=""
  local _msg=""
  local _stdin=""
  local _text=""
  #
  _stdin="$(awk '{print}; END {print "|||"}' /dev/stdin)"; _stdin="${_stdin%|||}"
  ### FINAL awk WORKS and is not time sensitive like 'read'
  # read -n1 -t1 __  && (( $? <= 128 ))  && { IFS= read -rd '' _stdin; _stdin="$__$_stdin"; } ### read LXCDT
  # read -N1 -t1 __  && (( $? <= 128 ))  && { IFS= read -rd '' _stdin; _stdin="$__$_stdin"; } ### FINAL read
  ### MAY FAIL DUE TO INSUFFICIENT WAIT TIME (-t1)
  # read -N1 -t1 __  && (( $? <= 128 ))  && { IFS0=$IFS; IFS= read -rd '' _stdin; IFS=$IFS0; _stdin="$__$_stdin"; }
  # read -N1 -t1 _stdin  && (( $? <= 128 ))  && { _stdin+="$(< /dev/stdin)"; }
  # _stdin="$(awk '{print}; END {print "|||"}' /dev/stdin)"; _stdin="${_stdin%|||}"           ### FINAL awk WORKS
  # _stdin="$(awk '{print}; END {print "|||"}' /dev/stdin)"; _stdin="${_stdin%$NL|||*}"       ### WORKS
  # _stdin="$(awk '{print}; END {print "|||"}' /dev/stdin)"; _nl='\n'; _stdin="${_stdin%%_nl|||*}"
  # awk '{print $0,"\n"}' /dev/stdin 2>&1 | IFS= read -rd '' _stdin
  # awk '{print}' /dev/stdin | read -rd '' _stdin
  # _stdin="$(awk '{print}' /dev/stdin; printf x)"
    # (( $? <= 128 ))  && { _stdin+="$(< /dev/stdin)"; }  || { _stdin=""; }
    # (( $? <= 128 ))  && {
    #   _stdin+="$(while IFS= read -r -d '' _line; do printf '%s\n' "$_line"; done < /dev/stdin)"
    #   # _stdin+="$(while IFS= read -r -d '' _line; do printf '%s\n' "$_line"; done < /dev/stdin)"; }  || { _stdin=""
    # }
  # }
  ### always accept multiline stdin, if any
  ### $(...) strips trailing newlines so temperarily append a non-newline to preserve blank lines
  ### 'awk' technique more reliable than 'read'
  ###
  ### read technique
  ### 'read -N1 -t1' is required as _stdin="$(< /dev/stdin)" hangs if pipe empty
  ###   read -N1 -t1 _stdin  && (( $? <= 128 ))  && { _stdin+="$(< /dev/stdin)"; }
  #
  _before="$(optionArg --before "$@" "|||")"  && { _text="${_before%|||}$_stdin"; }  || { _text="$_stdin"; }
  ### optional _before text is prepended to _stdin
  ###   A '|' is appended inside $(...) to prevent truncating newlines.
  ###     $(...) is designed to truncate trailing newlines. To prevent this, '|'
  ###     is appended inside $(...) then stripped off outside. Any character
  ###     except a newline could have been used.
  #
  # ARGS="$*"; inspVar ARGS _stdin _before _text _msg
  #
  _msg="$(
    sed --regexp-extended --expression '
      s/\\/\\134/g
      s/$/\\012/
      s/ /\\040/g
      s/\t/\\011/g
      s/\r/\\015/g
    ' <<< "$_text"
  )"
  #
  # _msg="$(
  #   {
  #     printf "%s$NL" "$_text"
  #     # echo -e "$_text"
  #   } | {
  #     sed --regexp-extended --expression '
  #       s/\\/\\134/g
  #       s/$/\\012/
  #     '
  #   } | {
  #     tr -d '\n'
  #   } | {
  #     sed --regexp-extended --expression '
  #       s/ /\\040/g
  #       s/\t/\\011/g
  #       s/\r/\\015/g
  #       s/\\012$//
  #     '
  #   }
  # )"
  #
  # _msg="$(
  #   {
  #     printf "%s$NL" "$_text"
  #   } | {
  #     sed --regexp-extended --expression '
  #       s/\\/\\134/g
  #       s/$/\\012/
  #     '
  #   } | {
  #     sed --regexp-extended --expression '
  #       s/ /\\040/g
  #       s/\t/\\011/g
  #       s/\r/\\015/g
  #       s/\\012$//
  #     '
  #   }
  # )"
  #
  isOption --escaped "$@"  && {
    _msg="$( sed --regexp-extended --expression 's/\\/\\\\/g' <<< $_msg || { cat "$_msg"; } )"
  }
  #
  printf "%s$NL" "$_msg"
  #
  # ARGS="$*"; inspVar ARGS _stdin _before _text _msg
  #
  return
}

function printDecoded () {
  fnInit "$FUNCNAME.20200427" "$@"  && return 0
  #
  local _msg="$*"
  #
  _msg="${_msg//&gt;/>}"
  _msg="${_msg//&lt;/<}"
  _msg="${_msg//&amp;/&}"
  # OBSOLETE
  # _msg="${_msg//&#37;/%}"
  # include format string so printf will not
  # interpret '%' in $_msg as a format placeholder
  #
  printf "%s" "$_msg"
}

function printEncoded () {
  fnInit "$FUNCNAME.20200426" "$@"  && return 0
  #
  local TEXT="$*"
  TEXT="${TEXT//&/&amp;}"
  TEXT="${TEXT//</&lt;}"
  TEXT="${TEXT//>/&gt;}"
  # TEXT="${TEXT//%/&#37;}"
  # include format string so printf will not
  # interpret '%' in $TEXT as a format placeholder
  #
  printf "%s" "$TEXT"
}

function processStatus () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  # processStatus --pid=...
  #
  local __=""
  local _pid=""
  local _command=""
  local _reNumber="$reNumber"
  local _syslog="/var/log/messages"
  local _processes=""
  local _sysmessages=""
  local _syserrorcount=""
  #
  if [[ ! "$1" ]]
  then
    _pid="$$"; _command="$(</proc/$_pid/comm)"
  else
    [[ "$1" =~ ^--pid     ]]  && { _pid="$(    optionArg --pid     "$@")"; }
    [[ "$1" =~ ^--command ]]  && { _command="$(optionArg --command "$@")"; }
    [[ "$1" =~ ^--        ]]  || { [[ "$1" =~ $_reNumber ]]  && _pid="$1"  || _command="$1"; }
    #
    [[ "$_pid"            ]]  || { _pid="$$"                         ; }
    ### Use pid of self ($$) if null
    #
    [[ "$_command"        ]]  || { _command="$(</proc/$_pid/comm)"   ; }
    ### get command name from procfs details if necessary
    #
    # _pid="$(pidof -s $_command)"
    ### pid of a process running command
    #
    # [[ "$_pid"               ]]  || { __="$(optionArg --pid "$@")"; _pid="${__:-$$}" ; }
    ### Use pid of self ($$) if null
    #
    # inspVar BASH_LINENO _pid _command
  fi
  #
  _processes="$(ps -ef | grep -E -v -e "grep" | grep "$_command")"
  _sysmessages="$(grep -i "$_command" "$_syslog")"
  _syserrorcount="$(grep -ic "ERROR" <<< "$_sysmessages")"
  #
  echo
  echo "Processes related to command '$_command' ..."
  printf "%s$NL" "$_processes"
  echo
  echo "Messages possibly related to '$_command' ($_syserrorcount errors) ..."
  echo "$_sysmessages"
  isOption --details "$@"  && {
    echo
    echo "Process $_pid ($_command) details ..."
    cat "/proc/${_pid}/status"
    return 0
  }
  echo
  #
  return 0
}

function processStatusShow () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  dialog --title "Process Status" -- "$(processStatus "$@")"
}


function pstree () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  dialog -- "$(ps -efH)"
  return 0
}

function readArray () {
  fnInit "$FUNCNAME.20200501" "$@"  && return 0
  #
  ######################################
  # echo "
  #   readArray function not yet working
  # " >&2
  # return 1
  ######################################
  #
  ### COPIED FROM dialogCombo()...
  #
  # readarray _selections  < <(optionArg -- "$@") >/dev/null  || {
  # # readarray -t _selections  < <(optionArg -- "$@") >/dev/null  || {
  #   while read _a; do _selections+=("$_a"); done < <(optionArg -- "$@")
  # }
  # ### copy selections into array for yad/zenity
  # ### if bash version does not support readarray builtin, do it with a loop
  # #
  # _selections+=( "$(inputStdin)" )
  # # _selections+=( "$(inputStdin)" )
  # # _stdin="$(inputStdin)"
  # ### optional redirected input
  #
  ### From https://github.com/cjungmann/yaddemo/blob/master/docs/bashreturnarray.md#returning-an-array-building-string
  # return_array_building_string()
  # {
  #    local ESEP="$1"
  #    local IFS=$'\n'
  #     local -a arr=(
  #         "one"
  #         "two words"
  #         "three
  # lines of
  # words"
  #     )
  #
  #    IFS="${ESEP}"
  #    echo "${arr[*]}"
  # }
  #
  # local IFS="$1"
  # echo "${*:2}"
  # # printf "'%s' " "${*:2}"
  local _fs=""
  local _fso=""
  local -a _arr
  #
  # IFS="${_fs}"
  printf "%s" "${arr[*]}"
  echo
  declare -p arr
  echo
  # echo -e "${arr[*]}"
  #
  exit

  local _a=""
  local _arrayname=""
  local -i _i
  #
  _arrayname="$1"
  _fs="${1:-$'\@'}"
  _fso="$IFS"
  #
  IFS=$'\n'
  #
  readarray ${!_arrayname}  < <(optionArg -- "${@:2}") || {
    _i=0
    while read _a; do ${!_arrayname[$_i]}="$_a"; ((++_i)); done < <(optionArg -- "${@:2}")
  }
  # readarray ${!_arrayname}  < <(optionArg -- "${@:2}") || {
  #   _i=0
  #   while read _a; do inspVar _a; ${!_arrayname[$_i]}="$_a"; inspVar !_arrayname[$_i]; ((++_i)); done < <(optionArg -- "${@:2}")
  # }
  #- inputStdin | readarray -t ${!_arrayname}
  ### build _list array for yad/zenity
  # TIMINGS...
  #   unset _list; time readarray -t _list  < <(optionArg -- "$@") >&2
  #     real  0m0.005s
  #     user  0m0.004s
  #     sys   0m0.000s
  #   unset _list; time while read _a; do _list+=("$_a"); done < <(kit optionArg -- "$@")  >&2
  #     real  0m0.070s
  #     user  0m0.000s
  #     sys   0m0.004s
  #
  # inspVar _a _arrayname !_arrayname[0] _i _a
  #
  # inspVar --func _selections[@]
  #
  return 0
}

function returnCode () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  [[ "$1" ]]  || { returnCode --help; return 0; }
  #
  (( $1 > 0  &&  $1 < 256 )) && return $1
  #
  return 0
}

function screenSize () {
  fnInit "$FUNCNAME.20190417" "$@"  && return 0
  #
  xrandr | awk '$0 ~ "*" {print $1}'
  #
  return $?
}

function scriptBusy () { aliasOf gtkSpinner "$@"; }

function standby () {    aliasOf gtkSpinner "$@"; }

function scriptExit () { aliasOf ___exit    "$@"; }
### DEPRECATED - kept for external dependancies

function scriptType () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  # STACKTOP="$(inspFnStackTop)"
  # FUNCNAME0="${FUNCNAME[0]}"
  # FUNCNAME1="${FUNCNAME[1]}"
  # FUNCNAME2="${FUNCNAME[2]}"
  # FUNCNAME3="${FUNCNAME[3]}"
  # inspVar STACKTOP FUNCNAME0 FUNCNAME1 FUNCNAME2 FUNCNAME3
  #
  printf "%s\n" "${FUNCNAME[(($(inspFnStackTop)))]}" "$@"
  # printf "%s\n" "${FUNCNAME[(($(inspFnStackTop)-1))]}" "$@"
}

function stderr () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _file
  #
  # ...
  isNotNull "$1"  && { _file="$(pathStr --path "$1")"; exec 2>>"$_file"; }
  #
  printf "$_file\n"
  #
  return 0
}

function stdinInput () {
  fnInit "$FUNCNAME.20191026" "$@"  && return 0
  #
  local _stdin=""
  #
  read -n1 -t1 _stdin  && {
    (( $? <= 128 ))  && { _stdin+="$(awk '{print}' /dev/stdin)"; printf "%s" "$_stdin"; return 0; }
  }
  ### accept multiline stdin, if any
  ###   Read 1 character from stdin
  ###   If times out then no data available so do nothing
  ###   If did not timeout then read the 1 character...
  ###     so append rest of the input to it and print it
  ###   NOTES...
  ###   - MAY FAIL IF INSUFFICIENT WAIT TIME (-t1)
  ###   - The 'read' is required since _stdin="$(< /dev/stdin)" hangs if null
  ###   - Fractional values not supported till bash 4+ so must wait a whole second
  ###   - Accepts input if any but does not hang waiting for input
  #
  return 1
}

function stdinReset () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  exec 0<&-
  ### close current pipeline input
  #
  exec 0</dev/tty
  ###reopen input fd with standard input
  #
  return $?
}

function sysPing () {
  fnInit "$FUNCNAME.20190423" "$@"  && return 0
  #
  local _hosts=""
  local _host_ips=""
  local _host_names=""
  local _hostsfile="/etc/hosts"
  local _title="Hosts Online"
  local _reNoFile='s/^.*\://'
  local _reNoName='s/\s.*$//'
  local _reNoIP='s/\s[0-9.]*//'
  #
  ### NOTE
  ###   kit fileQuery --like uses 'grep ... --with-filename ...'
  ###   so each line is prefixed with the hosts file filename followed by ':'
  #
  _hosts="$(fileQuery --select --from "/etc/hosts" --like "$reNonComment")"
  # _hosts="$(fileQuery --select --path "/etc" --file "hosts" --like "$reNonComment")"
  # _hosts="$(kit fileQuery --select --path "/etc" --file "hosts" --like "$reNonComment")"
  #
  _host_names="$(awk '{print $2}' <<< "$_hosts")"
  _host_ips="$(awk '{split($1, a, ":"); print a[2]}' <<< "$_hosts")"
  # _host_ips="$(cut --delimiter ' ' --fields 1 <<< "$_hosts" | cut --delimiter : --fields 2)"
  # _host_names="$(cut --delimiter ' ' --fields 2 <<< "$_hosts")"
  # _host_ips="$(sed -e "$_reNoFile" -e "$_reNoName" <<< "$_hosts")"
  # _hosts="$(sed -e 's/^.*\://' -e 's/\s.*$//' <<< "$_hosts")"
  #
  for _h in $_host_names
  do
    # echo "\Zb\Z1HOSTS\Zn$NL"
    #
    ping -c1 -W1 "$_h" >/dev/null 2>&1  && { printf "$BO$FGRN*  %10s is online$RS$NL" "$_h"; continue; }
    printf "$BO$FRED* %10s is offline$RS$NL" "$_h"
  done | command dialog
  #
  # _ARGS="$*"; inspVar --func
  #
  return 0
}

### DOES NOT OPEN A USABLE SESSION
###
# function termSession () {
#   fnInit ${FUNCNAME} "$@"  && return 0
#   #
#   local _cmd="$*"
#   local _hold=""
#   local _manager=""
#   local _stdin=""
#   local _in=""
#   #
#   if (( ${BASH_VERSINFO[0]} >= 4 ))
#   then
#     while read -t0.01 _in; do _stdin+="$_in$NL"; done
#   else
#     while read -t1    _in; do _stdin+="$_in$NL"; done
#   fi
#   ### accept multiline stdin, if any
#   ### fractional values not supported till ver 4+ so must wait a whole second
#   #
#   _hold="$(optionArg hold)"  && { _hold="--hold"; }
#   #
#   _manager="$(basename $(which roxterm))"; [[ "$_manager" ]]  || { _manager="$(basename $(which gnome-terminal)))"; }
#   #
#   # inspVar _hold _manager
#   #
#   case $UI in
#     CLI)
#       printf "%s\n" "$_msg$NL"
#       ;;
#     GUI)
#       case "$_manager" in
#         roxterm)
#           roxterm --tab --profile=Hold --execute "$_cmd"
#           ;;
#         gnome-terminal)
#           _geometry="${_geometry#-}"
#           ### strip off leading hyphen for zenity
#           #
#           gnome-terminal --profile=Default --geometry="$GEOMETRY_PL" --execute $_cmd $_stdin
#           ;;
#         *)
#           abortExit operationfailed "Unknown terminal manager:  '"$_manager"'"
#           ;;
#       esac
#       ;;
#     LOG)
#       _msg="Directory:  $_dir"
#       log --status "$_msg"
#       ;;
#     *)
#       abortUI
#   esac
#   #
#   return 0
# }

function termSize () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _term="$1"
  local _cols=""
  local _rows=""
  local _msg_anf="Requires a terminal device (i.e. /dev/pts/0)"
  local _msg_fnf="No terminal session on device $_term"
  #
  [[ "$_term"       ]]   || { errorShow argumentnotfound "$_msg_anf"; return 1; }
  ### _term is required since, as a script, there is no attached terminal to stty
  #
  isFileExists "$_term"  || { errorShow     filenotfound "$_msg_fnf"; return 1; }
  ### no terminal session attached to this device
  #
  _cols="$(stty -a <"$_term" | grep -Po '(?<=columns )\d+')"
  _rows="$(stty -a <"$_term" | grep -Po '(?<=rows )\d+')"
  ### get columns and rows
  ###   list all settings for the terminal session
  ###   select using Perl Regular Expression (PCRE) matching "lookbehind"
  ###     only(-o) the 1 or more digits(\d+) following 'columns ' and 'rows '
  #
  # ARGS="$*"; inspVar ARGS _term _cols _rows
  #
  printf "%dx%d\n" "$_cols" "$_rows"
  # printf "\nTerminal $_term:\n  Columns: %5d\n  Rows   : %5d\n" "$_cols" "$_rows"
  #
  return 0
}

function timeDate () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  # memory  >&2
  #
  printf "%s" "$(date +"%Y-%m-%d %H:%M:%S")"
  # date +"%Y-%m-%d %H:%M:%S"
  # date +'%Y-%m-%d %H:%M:%S'
  # printf "%s" "$(date +'%Y-%m-%d %H:%M:%S')"
  #
  return 0
}

function timeMs () {
  [[ "$FUNCNAME[1]" =~ fnInit|inspFn ]]  || { fnInit ${FUNCNAME} "$@"  && return 0; }
  #
  date +'%s%3N'
  # local _dt="$(date +'%s%3N')"
  #
  # printf "%s" "$_dt"
  #
  return 0
}

function tolower () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  # force all alpha characters in "$@" to lowercase
  echo "${@,,}"
  return
}

function tolower_tr () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  echo "$*" | tr '[:upper:]' '[:lower:]'
  return $?
}

function topic () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _topic="$1"
  local _source="$2"
  local _text=""
  local _indent=""
  local _out=""
  #
  [[ "$_topic"  ]]  || return 1
  [[ "$_source" ]]  || return 1
  #
  _text="$(echo "$_source" | grep --max-count=1 --regex=" *$_topic" -)"
  _indent="$(indentStr "$_text")"
  #
  _out="$(
    echo "$_source" |
    awk -v IN="^${_indent} " -v TXT="^$_text"  '
                $0 ~ TXT  {show=1;        next}
        show && $0 ~ IN   { $1=$1; print; exit}'
  )"
  ### retrieve all lines indented under _topic
  ### read into var _out so we strip out possible whitespace if nothing found
  #
  # _ARGS="$*"; inspVar --func
  #
  [[ "$_out" ]]  && { printf "%s$NL" "$_out"; return 0; }
  #
  return 1
}

function toupper () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  echo "$*" | tr '[:lower:]' '[:upper:]'
  return $?
}

function trapDebug () {
  trap trapInterrupt  INT
  ### reassert Ctrl-C trap so can abort listings
  #
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _fn=${FUNCNAME[1]}; [[ "$_fn" =~ 'main|source' ]]  || _fn+="()"
  # local _fn=${FUNCNAME[1]}; [[ "$_fn" =~ main|source ]]  || _fn+="()"
  #
  printf "  Debug:  %s.%05d:  %s:  %s\n" "$BASH_SOURCE" "$BASH_LINENO" "$_fn" "$(echo $BASH_CMD)"  >&2
}

function trapError () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  printf "\n  ERROR at line %5d, %s.%s():  %s\n" $BASH_LINENO $BASH_SOURCE ${FUNCNAME[1]} "$BASH_CMD"  >&2
}

function trapExit () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  # NOTE - NEVER USE in a kit library script?
  #   trap foo EXIT
  #     WHY?
  #       EXIT is signaled when the lib script ends so calling script never runs!
  #         Is there a way to do not exit from inside foo() in this situation?
  #           By checking ${FUNCNAME[$(callStackTop)]} ?
  #
  printf "\n  Received signal: Exit (SIGEXIT)\n"
  ___exit "$@"
}

function trapHangup () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  printf "\n  Received signal: Hangup (SIGHUP)\n"
  ___exit $?
}

function trapInterrupt () {
  local _rc=$?
  # fnInit ${FUNCNAME} "$@"  && return 0
  #
  trap - INT DEBUG
  ### disable this trap so it doesn't cascade
  #
  # local _args="${FUNCNAME[1]}"
  local _call=1
  local _files=""
  local _status=""
  local _msg=""
  #
  _status="${BASH_SOURCE[$_call+1]}(${BASH_LINENO[$_call]}).${FUNCNAME[$_call]}  (returned code $_rc)"
  #
  _msg="$(printAt 2 "$_status"; printAt 4 "Received signal:  Interrupt (SIGINT)"; printAt 8 "Remove temporary files?")"
  # _msg="$(printAt 2 "${_status}"; printAt 4 "Received signal:  Interrupt (SIGINT)"; printAt 8 "Remove temporary files?")"
  # _msg="$(printf "%-*s$NL" "2" "Hello")"
  # _msg="$(printf "%*s$NL" 40 "${_status}")"
  # _msg="$(printf "%*s %*s %*s" 2 "${_status}" 4 "Received signal:  Interrupt (SIGINT)" 8 "Remove temporary files?")"
  # _msg="$(printf "\n%*s\n%*s\n%*s\n" 2 "${_status}" 4 "Received signal:  Interrupt (SIGINT)" 8 "Remove temporary files?")"
  # _msg="$(printf "\n%*s${NL}%*s${NL}%*s%${NL}" 2 "${_status}" 4 "Received signal:  Interrupt (SIGINT)" 8 "Remove temporary files?")"
  # _msg="$(printf "\n"; printAt 2 "${_status}"; printAt 4 "Received signal:  Interrupt (SIGINT)"; printAt 8 "Remove temporary files?")"
  #
  _files="$(echo "some files")"
  #
  # ARGS="$@"; inspVar ARGS _msg
  #
  dialogConfirm --text "$_msg" --info "$_files"  && { gtkInfo "$_msgdone"; ___exit "$@"; }
  #
  ___exit "$@"
  # ___exit $?
}

function trapMemory () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  printf "\n  Received signal: Quit SIGBUS or SIGSEGV.  Memory Error. Exiting...\n"
  #
  ___exit "$@"
  # ___exit $?
}

function trapQuit () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  printf "\n  Received signal: Quit (SIGQUIT).  Core dumping...\n"
  #
  ___exit "$@"
  # ___exit $?
}

function trapTerminate () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  printf "\n  Received signal: Terminate (SIGTERM)\n"
  #
  ___exit "$@"
  # ___exit $?
}

function uiInit () { aliasOf ___initUIDLG "$@"; }

function varAll () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  ( set -o posix ; set )
}

function varFind () {
  fnInit "$FUNCNAME.20191025" "$@" && return 0
  #
  local _var="$1"
  local _found=
  local _awkcode=''
  local _metafile=""
  #
  _var="${_var/[-.]/_}"
  # _var="${_var/-/_}"
  ### allow hyphens and dots by converting them to underscores
  #
  _metafile="$(optionArg --metafile "$@")"
  _metafile="${_metafile:-$METAFILE}"; [[ "$_metafile" ]]  || { return 1; }
  ### requires default meta file if not supplied
  #
  [[ "$_var" =~ $reVar                                 ]]  || { return 1; }
  ### reject variables with invalid characters
  #
  [[ "${!_var}"                                        ]]  && { printf "%s\n" "${!_var}"; return 0; }
  ### print variable if already loaded and return
  #
  _awkcode='
    /^'"$_var"'="?/ { flag=1; print gensub(/^'"$_var"'="?/, "", 1); next}
    /^("|'"'"')$/   { flag=0 }
    flag            { print  }
  '
  # _awkcode='/^'"$_var"'=/,/^("|'"'"')$/ {print}'
  ### select multiline variable value
  #
  _found="$(awk "$_awkcode" "$_metafile")"
  ### variable must be read from $_metafile
  #
  [[ "$_found"                                         ]]  && { printf "%s\n" "$_found"; return 0; }
  #
  return 1
}

function varTrim () {
  fnInit "$FUNCNAME.20190421" "$@"  && return 0
  #
  local _s1="$1"
  local _s2=""
  #
  _s1="${_s1##*( )}"
  ### remove leading spaces
    #
  _s1="${_s1%%*( )}"
  ### remove trailing spaces
  #
  printf "%s" "$_s1"
  # until [[ "$_s2" == "$_s1" ]]; do _s2="${_s1# }"; done
  # until [[ "$_s2" == "$_s1" ]]; do _s2="${_s1% }"; done
  #
  # until _s2="${_s1# }"; [[ "$_s2" == "$_s1" ]]; do _s1="$_s2"; done
  # until _s2="${_s1% }"; [[ "$_s2" == "$_s1" ]]; do _s1="$_s2"; done
  #
  # _ARGS="$*"; inspVar --func
  #
  # echo "$_s"
  #
  # local _var="$*"
  # #
  # _var="${_var#"${_var%%[![:space:]]*}"}"
  # ### remove leading whitespace characters
  # #
  # _var="${_var%"${_var##*[![:space:]]}"}"
  # ### remove trailing whitespace characters
  #
  # printf "%s" "$_s2"
  #
  return 0
}

function version () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local _fn=""
  local _msg=""
  local _helptext=""
  local _topictext=""
  local _metafile="$METAFILE"
  #
  [[ "$1" =~ ^--    ]]  || { _fn="$1"            ; }
  [[ "$_fn"         ]]  || { _fn="${FUNCNAME[1]}"; }
  # _fn="$(optionArg --:1 "$@")"
  # _fn="$(argNonOption 1 "$@")"
  #
  _msg="kit v$kit_VERSION multi-call script ($kit_SCRIPT)"
  #
  if [[ "$_fn" ]]
  then
    _helptext="$(note "${_fn}_help" "$@" --metafile="$_metafile")"
    #
    if [[ "$_helptext"  ]]
    then
      _topictext="$(topic "Revised:" "$_helptext")"
      [[ "$_topictext" ]]  || { _topictext="$(topic "REVISED" "$_helptext")"      ; }
      [[ "$_topictext" ]]  && { _topictext="${_fn}() function revised $_topictext"; }
    fi
    #
    # _ARGS="$*"; inspVar --func
    #
    if [[ "$_topictext" ]]
    then
      _msg+="$NL  $_topictext"
    else
      _msg+="$NL  $_fn not found"
    fi
  fi
  #
  printf "%s$NL" "$_msg"
  #
  return 0
}

function versionIncrement () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  local __=""
  local _base=""
  local _bindir=""
  local _libdir=""
  local _ext=""
  local _homedir=""
  local _path=""
  local _script=""
  local _scrcur=""
  local _scrext=""
  local _scrnam=""
  local _scrver=""
  local _text=""
  local _title=""
  #
  _homedir="$HOMEDIR"
  _text="Reset default script to new version?"
  _title="Increment Script Version"
  #
  # _ARGS="$*"; inspVar --func
  #
  [[ "$1" =~ ^--        ]]  || { _script="$1"; }
  [[ "$_script"         ]]  || { $FUNCNAME --help; return 1; }
  #
  _path="$(  pathStr --path "$_script")"
  _libdir="$(pathStr --dir  "$_script")"
  _base="$(  pathStr --base "$_script")"
  _ext="$(   pathStr --ext  "$_script")"
  # _ext="$(   pathStr --ext  "$_script")"; [[ "$_ext" ]]  && { _ext=".$_ext"; }
  ### decompose script name given
  #
  _scrnam="${_base%-[0-9]*}"
  _scrver="${_base/$_scrnam/}"
  _scrext="${_ext}"
  ### separate scriptname and version suffix
  #
  __="$(files --reg ${_libdir}/${_scrnam}${globVer}${_scrext:+.$_scrext})"
  #
  inspVar --func
  #
  dialogConfirm --title "$_title" --text "Proceed?" --info "$__"  || return 1
  # dialogConfirm --title "$_title" --text "Proceed?" --info "$(ls ${_libdir}/${_scrnam}${globVer}${_scrext:+.$_scrext})"  || return 1
  #
  _scrcur="$(tail -n1 <<< "$__")"
  # _scrcur="$(ls ${_libdir}/${_scrnam}${globVer}${_ext:+.$_ext} | tail -n1)"
  #
  dialogConfirm --title "$_title" --text "Proceed?" --info "$_scrcur"  || return 1
  ### find highest numbered version of _script
  #
  #
  _bindir="$_homedir/bin"
  ### $PATH directory containing symlink to script
  #
  _newver="$(optionArg --newversion "$@")"
  [[ "$_newver" ]]  || { _newver="$(printf "%03d" "$( ((_scrver + 1)) )")"; }
  #
  inspVar --func
  #
  dialogConfirm --title "$_title" --text "Proceed?" --info "$(inspVar --func HOMEDIR 2>&1)"  || return 1
  ### confirmation or bail out
  #
  [[ "$_scrver" ]]  || {
    _scrver="000"
    mv "${_libdir}/${_scrnam}${_ext:+.$_ext}" "${_libdir}/${_scrnam}${_scrver:+-$_scrver}${_ext:+.$_ext}"
    ### append version -000
  }
  ### append version suffix to original if not already there
  #
  archive "${_libdir}/${_scrnam}${_scrver:+-$_scrver}${_ext:+.$_ext}"
  ### archive existing script
  #
  _script="${_libdir}/${_scrnam}${_newver:+-$_newver}${_ext:+.$_ext}"
  ### _script now includes full path and new version suffix
  #
  cp -a "${_libdir}/${_scrnam}${_scrver:+-$_scrver}${_ext:+.$_ext}" "$_script"
  # cp -a "$_script" "${_libdir}/${_scrnam}${_newver:+-$_newver}${_ext:+.$_ext}"
  ### create new version of script
  #
  archive "$_script"
  ### archive new version of script
  #
  ( cd "$_bindir"; ln -s "$_script" )
  # (cd "$BINDIR"; ln -s "$LIBDIR/${_script}-${_newver}${_ext}")
  ### create new symlink in ../bin
  #
  inspVar --func
  #
  dialogConfirm --title "$_title"  --text "$_text"  --info "$_base -> $_scrnam-$_newver${_ext:+.$_ext}"  || return 1
  ### confirmation or bail out
  #
  ( cd "$_libdir"; ln -sf "$_scrnam-$_newver${_ext:+.$_ext}" "$_base${_ext:+.$_ext}" )
  # ( cd "$_libdir"; ln -sf "${_script}-${_newver}${_ext}" "$_script" )
  # (cd "$LIBDIR"; ln -sf "${_script}-${_newver}${_ext}" "$_script")
  ### reset default script to new version
  #
  ### TODO?
  ###   create new symlink in ../bin ON OTHER HOSTS???
  ###     Could global code at beginning of this script do this safely
  ###     since these links already set see, to start kit but it aborts
  ###     with a '' $UI error.
  #
  inspVar --func
  #
  return 0
}

function versionShow () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  # _ARGS="$*"; inspVar --func
  #
  dialog --middle -- "$(version "$@")"
  return 0
}

function working () {
  fnInit ${FUNCNAME} "$@"  && return 0
  #
  yad --progress --progress-text="Working..." --timeout=2 --no-buttons "$@" & ### background
  ### execute in background
}

function wwwAddArticle () {
  fnInit ${FUNCNAME} "$@" --help-text="
NAME
    wwwAddArticle - Add an article (box) to an existing HTML file

        --- IN DEVELOPMENT ---

SYNOPSIS
    wwwAddArticle --htmlfile FILE --articles ARTICLE...

DESCRIPTION
    Add an article (box) to an existing HTML file.

ARGUMENTS
    --htmlfile FILE
        FILE is the full path of the the destination HTML file to add the
        article HTML code fragment to.
    --articles ARTICLE...
        ARTICLE is a file containing an HTML code fragment to add to FILE.
        There may be any number of ARTICLE files.

EXAMPLES
    kit wwwAddArticle \\
      --htmlfile '/home/DocSalvager/www/DOCSAL/docsalvager.info/article/default.html' \\
      --articles '/home/DocSalvager/www/DOCSAL/docsalvager.info/article/new-docsal.html'

REVISED
    20180407 by docsalvager
" && { return 0; }  || [[ "$1" ]]  || { "$FUNCNAME" --help; return 0; }
  ### if no arguments, show --help
  #
  #
  local _file=""
  local _htmlarticle=""
  local _htmldefault=""
  local _htmlfile=""
  local _like=""
  local _path=""
  local _where=""
  #
  _htmlarticle="/home/DocSalvager/www/DOCSAL/docsalvager.info/article/new-docsal.html"
  _htmldefault="/home/DocSalvager/www/DOCSAL/docsalvager.info/article/default.html"
  _htmlfile="/home/DocSalvager/www/DOCSAL/docsalvager.info/test.html"
  _like="      <div class=\"main\">$NL"
  _where="      <div class=\"main\">$NL"
  #
  _path="${_htmlfile%/*}"
  _file="${_htmlfile##*/}"
  _text="$(<$_htmlarticle)$NL"
  #
  ARGS="$*"; inspVar ARGS _htmldefault _htmlarticle _htmlfile _path _file _like _text
  #
  gtkError "fileQuery --update of multiline --like clauses not yet supported"
  # fileQuery --update --path "$_path" --file "$_file" --where "$_where" --like "$_like" --set "$_like$_text"
  #
  printf "%s$NL" "$_htmlfile"
  return 0
}

function wwwNewPage () {
  fnInit ${FUNCNAME} "$@" --help-text="
NAME
    wwwNewPage - Create a new HTML page file from a default template

        --- IN DEVELOPMENT ---

SYNOPSIS
    wwwNewPage --htmlfile FILE --htmldefault TEMPLATE

DESCRIPTION
    Create a new HTML page file from a default template.

ARGUMENTS
    --htmlfile FILE
        The full path of the destination HTML file to be created.
    --htmldefault TEMPLATE
        A default prototype template HTML file to be copied to FILE.

REVISED
    20171206 by docsalvager
" && { return 0; }  || [[ "$1" ]]  || { "$FUNCNAME" --help; return 0; }
  ### if no arguments, show --help
  #
  #
  local _htmldefault="/home/DocSalvager/www/DOCSAL/docsalvager.info/article/default.html"
  local _htmlfile="/home/DocSalvager/www/DOCSAL/docsalvager.info/test.html"
  #
  ARGS="$*"; inspVar ARGS _htmldefault _htmlfile
  #
  cp -a "$_htmldefault" "$_htmlfile"
  #
  printf "%s$NL" "$_htmlfile"
  return 0
}

function xAt () {
  fnInit "$FUNCNAME.20191016" "$@"  && return 0
  #
  local _classstr=""
  local _cmdline=""
  local _cmdpid=""
  local _geometry=""
  local _winclass=""
  local _winid=""
  local _x=""
  local _y=""
  local _w=""
  local _h=""
  #
  [[ "$1" =~ ^--         ]]  || { _cmdline="$@"; }
  [[ "$_cmdline"         ]]  || {
    _cmdline="$(optionArg --cmdline "$@")"  || { $FUNCNAME --help; return 1; }
  }
  ### _cmdline is required
  #
  _x="$(optionArg --X "$@")" || { _x="-1"; }
  _y="$(optionArg --Y "$@")" || { _y="-1"; }
  _w="$(optionArg --W "$@")" || { _w="-1"; }
  _h="$(optionArg --H "$@")" || { _h="-1"; }
  # _geometry="$(optionArg --geometry "$@")"  && {
  #   _w="${_geometry%%x*}"; _w="${_w:- 30}"
  #   _h="${_geometry#*x}" ; _h="${_h%%+*}"; _h="${_h:- 30}"
  #   _x="${_geometry#*+}" ; _x="${_x%%+*}"; _x="${_x:- 0}"; [[ "$_x" == "$_geometry" ]]  && { _x=0; }
  #   _y="${_geometry##*+}"; _y="${_y:- 0}"; [[ "$_y" == "$_geometry" ]]  && { _y=0; }
  # }
  #
  $_cmdline 2>/dev/null  &
  ### run command that opens the window
  #
  _cmdpid=$!
  ### get last process pid
  #
  sleep .8
  ### wait for window to be mapped
  #
  ################################################################
  #
  # FOR FUTURE REFERENCE (currently using wmctrl WIN_ID instead)
  #
  # _classstr="$(wmctrl -lxp | grep $_cmdpid | cut --delimiter=' ' --fields=6)"
  # ### _classstr is the 4th visible column in wmctrl list
  # ### but fields must be '6' instead of '4' due to hidden fields(?)
  # #
  # _winclass="${_classstr%%.*}"
  # ### _classstr is in the format <class.classname> (?)
  #
  # xdotool search $_winclass windowsize 600 900
  #
  ################################################################
  #
  _winid="$(wmctrl -lxp | grep " $_cmdpid " | cut --delimiter=' ' --fields=1)"
  # _winid="$(winIdOfPid $_cmdpid)"
  ### window id (in hex -- 0x....)
  #
  wmctrl -i -r $_winid -e 0,$_x,$_y,$_w,$_h
  ### resize and reposition window
  #
  # _ARGS="$*"; inspVar --func
  #
  return 0
}

function xUrgent () {
  fnInit "$FUNCNAME.20191106" "$@"  && return 0
  #
  local _regex="$1"
  local _state="$2"
  local _errmsg="  No window with name(title), class, or classname matching regex '$_regex'"
  local -a _windows
  #
  [[ "$_regex" ]]  || { $FUNCNAME --help; return 1; }
  ### _regex is required
  #
  case "$_state" in
     on|'')  _urgency=1; _state="on";;
       off)  _urgency=0; _state="off";;
         *)  _urgency=1; _state="on";;
  esac
  #
  _windows=( "$(xdotool search $_regex)" )
  #
  _ARGS="$*"; inspVar --func
  #
  xdotool search $_regex set_window --urgency $_urgency  %1  || { errorShow operationfailed "$_errmsg"; return 1; }
  #
  echo "Set these windows urgency to $_state ..."
  printf "  %s$NL" ${_windows[@]}
  #
  return 0
}

function xUrgentActive () {
  fnInit "$FUNCNAME.20191016" "$@"  && return 0
  #
  local _activeWinId=""
  local _activeWinIdLine=""
  local _id=""
  local _tmpfile=""
  #
  _tmpfile="$TMPDIR/$FUNCNAME"
  ### initialize
  #
  _activeWinIdLine="$(xprop -root | grep _NET_ACTIVE_WINDOW\(WINDOW\) )"
  _activeWinId="${_activeWinIdLine:40}"
  echo "$_activeWinId" > "$_tmpfile"
  for _id in `wmctrl -l | cut -d " " -f 1`; do
      xprop -id "$_id" | grep "_NET_WM_STATE_DEMANDS_ATTENTION" 2>&1 > /dev/null
      #
      (( $? == 0 ))  && { wmctrl -i -a "$_id"; return 0; }
  done
  #
  return 1
}

function xWindows () {
  fnInit "$FUNCNAME.20191106" "$@"  && return 0
  #
  echo "
WINDOW_ID  DT PID    X    Y    W    H    WM_CLASS.CLASSNAME(?) HOST TITLE"
  wmctrl -lGxp; echo
  ### list open windows with their pids and WM_CLASS
  #
  return 0
}

function yad () {
  fnInit "$FUNCNAME.20180208" "$@"  && return 0
  #
  $YAD "$@"
}


###############################################################################
###
### INITIALIZATION & EXECUTION
###
###############################################################################

# echo -e "\nmain:  INHERITED ENVIRONMENT VARIABLES..."
# inspVar $ENVVARS
# exit

# echo -e "\nmain:  SCRIPT VARIABLES BEFORE ___init()..."
# inspVar --script
# exit

___init "$@"
### unconditionally initialize global variables including CMD

# echo "
# BASH_SOURCE: $BASH_SOURCE
# SCRIPT:      $SCRIPT
# SCRIPTARGS:  $SCRIPTARGS
# HOME:        $HOME
# " >&2
# return

# echo -e "\nmain:  SCRIPT VARIABLES AFTER ___init()..."
# inspVar --func CMD[@]
# echo "CMD[@]:  ${CMD[@]}"  >&2
### diagnostics

isExecuted  && { "${CMD[@]}"; ___exit "${CMD[@]}"; }
# isExecuted  && { $CMD "${CMD[@]}"; ___exit; }
# isExecuted  && { "${CMD[@]}"; inspVar --func CMD[@]; ___exit "${CMD[@]}"; }
### If executed instead of sourced, this begins execution. Place a copy
### of this line, exactly as is, at the the end of any scripts that source
### this script. That will cause the script to run as if all of the variables
### and functions in this script (kit-000) were part of the other script.
### NOTE
###   $CMD = ${CMD[0]} which is the command(function) to execute
###   ${CMD[@]} is the command followed by all its arguments
